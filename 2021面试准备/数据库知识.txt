2021-02-26 面试准备
MySQL 数据库知识准备

	1.基础语法
		1.执行顺序
			from->join->on->where->group by->avg,sum->having->select->distinct->order by->limit
	2.优化查询
		1.SQL优化分为三个方面
			1.代码层面优化
				1.减少查询
				2.使用缓存
			2.建表优化
				1.建表三范式
					1.字段不可分
					2.有主键,非主键字段依赖主键
					3.非主键字段不能互相依赖
				2.索引建立
					1.normal 普通索引
					2.unique 唯一索引
						表示唯一的,不允许重复的索引
					3.full text 全文索引
						表示全文索引

			3.查询优化
				1.索引适用场景以及索引失效场景
				2.善用SQL语法,分组,union,exist,in等
	3.索引
		1.索引的数据结构
		2.聚合索引
		3.为什么要使用这种数据结构?
	4.索引失效
		1.索引失效的场景
		2.为何会失效?
	5.执行引擎
		1.InnoDB,MyIsam等, 执行引擎之间的区别

		1.InnoDB
			优点：InnoDB是一个事务型的存储引擎，有行级锁定和外键约束，提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，设计目标是处理大容量数据库系统；
			缺点：不支持全文索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表；
			适用场景：经常更新的表，适合处理多重并发的更新请求，需要事务、外键；


			查询InnoDB全局变量
			show global variables;

		2.MyIsam
			优点：支持全文类型索引，索引和记录分开存储，并存储了表的行数，所以select count(*)效率很高（不加where）；
			缺点：不支持数据库事务，更新操作需要锁定整个表，不支持行级锁和外键；
			适用场景：经常读取数据的场合，更新操作少；

		

		对比:
			特点:
				1.InnoDB比MyIsam支持更高的并发,InnoDB的锁粒度为行级锁,MyIsam的锁粒度为表级锁;相比之下,MyIsam不容易出现死锁情况
				2.可恢复性上,InnoDB是有事务日志,所以在产生数据库崩溃等问题后,可以通过日志文件恢复数据,MyIsam没有事务日志
				3.查询性能,MyIsam优于InnoDB,因为InnoDB在查询过程中,是维护数据缓存,而查询过程是通过先定位到行所在的数据块,然后在数据块中定位到数据所在的内存地址可以找到数据
				4.表结构文件上,MyIsam的表结构文件包括 .frm(表结构定义), MYI(索引), MYD(数据); 而InnoDB的表数据文件为 .ibd()和 .frm(表结构定义)



mysql执行解析过程
https://www.cnblogs.com/fanguangdexiaoyuer/p/10268570.html


mysql的InnoDB索引原理
https://www.cnblogs.com/williamjie/p/11081081.html

	B+ tree 数据结构
		1.B+ tree的分裂:
			当一个节点满时,分配一个新的节点,并将原节点中1/2的数据复制到新的节点,最后在父节点中添加新节点的指针,B+ tree的分裂只影响了原节点和父节点,而不会影响兄弟节点,所以它不需要指向兄弟节点的指针

		2.B+ tree的检索
			B+ tree适合作为数据库的基础结构是因为计算机的内存-机械硬盘两层存储结构,内存可以完成快速的随机访问(随机访问: 即给出任意一个地址,要求返回这个地址存储的数据)但是容量比较小,而硬盘的随机访问要经过机械动作(1磁头移动,2盘片移动), 访问效率比内存低几个数量级,但是机械硬盘容量大;典型的数据库容量远远超过可用内存大小,这就决定了在B+ tree中检索一条数据可能要经过几次磁盘IO才能完成通常向下读取一个节点的动作可能会是一次磁盘IO操作，不过非叶节点通常会在初始阶段载入内存以加快访问速度。同时为提高在节点间横向遍历速度，真实数据库中可能会将图中蓝色的CPU计算/内存读取优化成二叉搜索树（InnoDB中的page directory机制）。

		可以说数据库必须有索引，没有索引则检索过程变成了顺序查找，O(n)的时间复杂度几乎是不能忍受的。我们非常容易想象出一个只有单关键字组成的表如何使用B+树进行索引，只要将关键字存储到树的节点即可。当数据库一条记录里包含多个字段时，一棵B+树就只能存储主键，如果检索的是非主键字段，则主键索引失去作用，又变成顺序查找了。这时应该在第二个要检索的列上建立第二套索引。  这个索引由独立的B+树来组织。有两种常见的方法可以解决多个B+树访问同一套表数据的问题，一种叫做聚簇索引（clustered index ），一种叫做非聚簇索引（secondary index）。这两个名字虽然都叫做索引，但这并不是一种单独的索引类型，而是一种数据存储方式。

			1.对于聚簇索引存储来说，行数据和主键B+树存储在一起，辅助键B+树只存储辅助键和主键，主键和非主键B+树几乎是两种类型的树。
			2.对于非聚簇索引存储来说，主键B+树在叶子节点存储指向真正数据行的指针，而非主键。

	　　InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。

	　　MyISM使用的是非聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。


	聚簇索引的优势:
	　　我们重点关注聚簇索引，看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，这不是多此一举吗？聚簇索引的优势在哪？
		　　1 由于行数据和叶子节点存储在一起，这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。

		　　2 辅助索引使用主键作为"指针" 而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个"指针"。也就是说行的位置（实现中通过16K的Page来定位，后面会涉及）会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。


	Page结构
		Page是整个InnoDB磁盘管理的最小单位,与数据库相关的所有内容都存储在这种Page结构里,Page分为几种类型
			1.数据页 B-tree Node
			2.Undo页 Undo Log Page
			3.系统页 system Page
			4.事务数据页 Transaction system Page

		单个Page的大小为16K(编译宏UNIV_PAGE_SIZE控制), 每个Page使用一个32位的int值来唯一标识，这也正好对应InnoDB最大64TB的存储容量（16Kib * 2^32 = 64Tib）。一个Page的基本结构如下图所示

	　　每个Page都有通用的头和尾，但是中部的内容根据Page的类型不同而发生变化。Page的头部里有我们关心的一些数据：
			1.
	    我们重点关注和数据组织结构相关的字段：Page的头部保存了两个指针，分别指向前一个Page和后一个Page，头部还有Page的类型信息和用来唯一标识Page的编号。根据这两个指针我们很容易想象出Page链接起来就是一个双向链表的结构。


	    再看看Page的主体内容，我们主要关注行数据和索引的存储，他们都位于Page的User Records部分，User Records占据Page的大部分空间，User Records由一条一条的Record组成，每条记录代表索引树上的一个节点（非叶子节点和叶子节点）。在一个Page内部，单链表的头尾由固定内容的两条记录来表示，字符串形式的"Infimum"代表开头，"Supremum"代表结尾。这两个用来代表开头结尾的Record存储在System Records的段里，这个System Records和User Records是两个平行的段。InnoDB存在4种不同的Record，它们分别是
	    	1.主键索引树非叶节点 
	    	2.主键索引树叶子节点 
	    	3.辅助键索引树非叶节点 
	    	4.辅助键索引树叶子节点。
		这4种节点的Record格式有一些差异，但是它们都存储着Next指针指向下一个Record。后续我们会详细介绍这4种节点，现在只需要把Record当成一个存储了数据同时含有Next指针的单链表节点即可。



		现在看下如何定位一个Record：
		　　1 通过根节点开始遍历一个索引的B+树，通过各层非叶子节点最终到达一个Page，这个Page里存放的都是叶子节点。
		　　2 在Page内从"Infimum"节点开始遍历单链表（这种遍历往往会被优化），如果找到该键则成功返回。如果记录到达了"supremum"，说明当前Page里没有合适的键，这时要借助Page的Next Page指针，跳转到下一个Page继续从"Infimum"开始逐个查找	   
	    	



MySQL 索引
https://zhuanlan.zhihu.com/p/113917726
	1.hash
		只能用于精确查找
	2.二叉树(BST,红黑树,AVL)
		1.BST 的查询的时间复杂度为O(lgn),但是在极端情况下会退化成链表,时间复杂度变为O(n)
		2.红黑树 如果是顺序插入的时候,那么整棵树会右倾,对于查找性能方面消耗也是巨大的
		3.AVL 总体来说是比较平衡的,但是也没有解决红黑树的问题,数据库的查询瓶颈是在磁盘的IO次数,所以在设计数据库索引的时候应该尽可能地减少磁盘的IO次数
	3.B树
		1.优秀的检索速度,时间复杂度为O(h*lgn),其中h为树高,n为每个节点关键词的个数
		2.尽可能地减少了IO,加快了检索的次数
		3.可以支持范围查找
	4.B+树
		B树和 B+树有什么不同呢？
			1.B 树一个节点里存的是数据，而 B+树存储的是索引（地址），所以 B 树里一个节点存不了很多个数据，但是 B+树一个节点能存很多索引，B+树叶子节点存所有的数据。
			2.B+树的叶子节点是数据阶段用了一个链表串联起来，便于范围查找。



	mysql的执行引擎以插件的方式设计,常见的有两种InnoDB和MyIsam
		Innodb 创建表后生成的文件有：

		frm:创建表的语句
		idb:表里面的数据+索引文件
		Myisam 创建表后生成的文件有

		frm:创建表的语句
		MYD:表里面的数据文件（myisam data）
		MYI:表里面的索引文件（myisam index）

		InnoDB将索引和数据放在一起,这种叫聚簇索引;而MyIsam将数据文件和索引文件分开放,这种叫非聚簇索引


MySQL 索引的原理以及SQL优化
https://tech.meituan.com/2014/06/30/mysql-index.html




索引原理
https://baijiahao.baidu.com/s?id=1661980510559470562&wfr=spider&for=pc
	1.回表
		会出现回表的原因是,mysql的InnoDB是聚簇索引,辅助索引叶子节点存储的是主键key,非叶子节点存储的是索引列;所以在命中索引之后,如果查询返回的列除了索引所包含的列之外还包含了其它列,就会进行回表
	2.索引覆盖
		简单来说,索引查询, 返回索引列;不需要回表;






数据库隔离级别
https://www.cnblogs.com/myseries/p/10748912.html 






面试题(高级架构)
https://www.cnblogs.com/williamjie/p/11139302.html




现在的问题是快点写好简历,然后开始投递面试







规划一下简历内容

云票务
	springboot + mybatis + xxl-job-admin (开源分布式调度框架基于netty)
	1.使用mysql存储过程进行交易数据迁移 (亿级别数据量迁移)
	2.项目迁移(下单服务, 验票服务, 定时任务服务, 数据上报服务)以及项目基础代码编写 (基于spring扩展对定时任务底层架构代码编写)
	3.代码重构
	4.使用责任链模式封装基础jar供其它项目使用,减少重复代码

知旅行
	spring + springmvc + mybatis
	key word :
		下单, 验票, 核销, 预警, 
		后台模块:
			商品
			凭证


前置服务器
	netty + httpClient
	1.使用建造者与迭代器模式模式,重构之前代码
	2.使用cas切换上下文,保证服务器节点可用

















