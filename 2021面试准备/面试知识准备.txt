#######################################[java基础]#######################################

HashMap
	1.put方法
		loadFactor 加载因子
			为什么是0.75
			提高空间利用率和 减少查询成本的折中，主要是泊松分布，0.75的话碰撞最小，
			HashMap有两个参数影响其性能：初始容量和加载因子。容量是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动扩容之前可以达到多满的一种度量。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行扩容、rehash操作（即重建内部数据结构），扩容后的哈希表将具有两倍的原容量。

			通常，加载因子需要在时间和空间成本上寻求一种折衷。
			加载因子过高，例如为1，虽然减少了空间开销，提高了空间利用率，但同时也增加了查询时间成本；
			加载因子过低，例如0.5，虽然可以减少查询时间成本，但是空间利用率很低，同时提高了rehash操作的次数。
			在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少rehash操作次数，所以，一般在使用HashMap时建议根据预估值设置初始容量，减少扩容操作。

			选择0.75作为默认的加载因子，完全是时间和空间成本上寻求的一种折衷选择;

		threshold
			扩容阈值 一般为 loadFactor*capacity

		modCount
			HashMap被改变的次数,因为HashMap是不安全的,所以在迭代的时候hashMap的结构变化了,就会抛出ConcurrentModifyException

		1.如果table为null,那么进行resize方法扩容
			resize干了什么?
				resize是HashMap的扩容方法
					1.判断是不是已经扩容到了最大值(1>>30)
					2.判断扩容后要小于最大值并且旧容器需要大于最小值
					3.之后将遍历旧的table,将值放到新的table里面,重新计算每个Node的位置应该放在哪里

		2.如果table的对应hash的下标 --> (n - 1) & hash
			为什么要这么做? 这样做的原因 确定下标的范围不会超过数组的最大值

		处理hash冲突的几种方式:
			1.开放定址法
				1.线性探查法
					简单来说就是,当发生hash冲突的时候,就以冲突位置为起点,步长为1循环查找,直到找到一个空位置将元素插进去,循环完了都找不到说明容器满了。就像你去一条街上的店里吃饭，问了第一家被告知满座，然后挨着一家家去问是否有位置一样。
				2.线性补偿探测法：di=Ｑ　下一个位置满足 Hi=(H(key) + Ｑ) mod m i=1,2,...k(k<=m-1) ，要求 Q 与 m 是互质的，以便能探测到哈希表中的所有单元。
				3.伪随机探测再散列：di=伪随机数序列。还是那个例子，这是完全根据心情去选一家店来问了
					缺点：
						1.这种方法建立起来的hash表当冲突多的时候数据容易堆聚在一起，这时候对查找不友好；
						2.删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点
						当空间满了，还要建立一个溢出表来存多出来的元素。
			2.再hash法
				对值再进行一次hash函数的运算,直到没有冲突为止
			3.公共溢出区
				设置一个公共溢出区,一旦发生hash冲突,那么都填入溢出表
			4.链地址法




同事分享,脑图
	https://naotu.baidu.com/file/b61fc4ab88185e5aba9508dacce4257d?token=6f7893f740536c9a
	https://naotu.baidu.com/file/aaf627cd4354acb836e1ad6a83faacba?token=71b7292f998b60e0