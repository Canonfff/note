#######################################[java基础]#######################################

HashMap
	1.put方法
		loadFactor 加载因子
			为什么是0.75
			提高空间利用率和 减少查询成本的折中，主要是泊松分布，0.75的话碰撞最小，
			HashMap有两个参数影响其性能：初始容量和加载因子。容量是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动扩容之前可以达到多满的一种度量。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行扩容、rehash操作（即重建内部数据结构），扩容后的哈希表将具有两倍的原容量。

			通常，加载因子需要在时间和空间成本上寻求一种折衷。
			加载因子过高，例如为1，虽然减少了空间开销，提高了空间利用率，但同时也增加了查询时间成本；
			加载因子过低，例如0.5，虽然可以减少查询时间成本，但是空间利用率很低，同时提高了rehash操作的次数。
			在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少rehash操作次数，所以，一般在使用HashMap时建议根据预估值设置初始容量，减少扩容操作。

			选择0.75作为默认的加载因子，完全是时间和空间成本上寻求的一种折衷选择;

		threshold
			扩容阈值 一般为 loadFactor*capacity

		modCount
			HashMap被改变的次数,因为HashMap是不安全的,所以在迭代的时候hashMap的结构变化了,就会抛出ConcurrentModifyException

		1.如果table为null,那么进行resize方法扩容
			resize干了什么?
				resize是HashMap的扩容方法
					1.判断是不是已经扩容到了最大值(1>>30)
					2.判断扩容后要小于最大值并且旧容器需要大于最小值
					3.之后将遍历旧的table,将值放到新的table里面,重新计算每个Node的位置应该放在哪里

		2.如果table的对应hash的下标 --> (n - 1) & hash
			为什么要这么做? 这样做的原因 确定下标的范围不会超过数组的最大值

		处理hash冲突的几种方式:
			1.开放定址法
				1.线性探查法
					简单来说就是,当发生hash冲突的时候,就以冲突位置为起点,步长为1循环查找,直到找到一个空位置将元素插进去,循环完了都找不到说明容器满了。就像你去一条街上的店里吃饭，问了第一家被告知满座，然后挨着一家家去问是否有位置一样。
				2.线性补偿探测法：di=Ｑ　下一个位置满足 Hi=(H(key) + Ｑ) mod m i=1,2,...k(k<=m-1) ，要求 Q 与 m 是互质的，以便能探测到哈希表中的所有单元。
				3.伪随机探测再散列：di=伪随机数序列。还是那个例子，这是完全根据心情去选一家店来问了
					缺点：
						1.这种方法建立起来的hash表当冲突多的时候数据容易堆聚在一起，这时候对查找不友好；
						2.删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点
						当空间满了，还要建立一个溢出表来存多出来的元素。
			2.再hash法
				对值再进行一次hash函数的运算,直到没有冲突为止
			3.公共溢出区
				设置一个公共溢出区,一旦发生hash冲突,那么都填入溢出表
			4.链地址法

	为什么HashMap桶中的树超过8个才转成红黑树
		https://www.cnblogs.com/williamjie/p/11168133.html



1.final 关键字的作用
	1.修饰类, 修饰类之后不能被继承,其成员方法隐式底被指定成final;

	2.修饰方法, 在<java编程思想中> 使用final方法的原因有两个:
		1.将方法锁定, 不希望方法被子类覆盖
		2.提高效率, 在早期的java版本中,会将final方法转为内嵌调用,但是方法过于庞大,可能会看不到内嵌调用的带来任何性能;而现在的java版本中,不需要使用final方法进行优化了

2.== 和 equals 的区别是什么？
	1.== 
		如果比较的是两个基础类型,那么即使他们类型不相同,只要值相等,也都返回true; 如果两个操作数是引用类型,那么只有两个引用变量的类型具有父子关系时才能进行比较,而且只有这两个引用必须同时指向同一个对象,才会返回true
	2.equals
		equals是Object类里面的方法,Object类实际上就是使用==进行比较的结果


3.String属于基础的数据类型么?
	String不是基础数据类型,而是引用数据类型;
	String的值是存储在常量池里面的
	如果是 String str = "abc"; 这种是直接指向常量池的
	如果是 String str1 = new String("abc"); 这种会在堆内存中构建一个区域,然后这个区域存储的是常量池的地址,如果没有abc,那么就创建一个"abc";


4.为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object 类里？
	1.wait 和 notify 不仅仅是普通方法或同步工具，更重要的是它们是 Java 中两个线程之间的通信机制。对语言设计者而言, 如果不能通过 Java 关键字(例如 synchronized)实现通信此机制，同时又要确保这个机制对每个对象可用, 那么 Object 类则是的正确声明位置。记住同步和等待通知是两个不同的领域，不要把它们看成是相同的或相关的。同步是提供互斥并确保 Java 类的线程安全，而 wait 和 notify 是两个线程之间的通信机制。
	2.每个对象都可上锁，这是在 Object 类而不是 Thread 类中声明 wait 和 notify 的另一个原因。
	3.在 Java 中为了进入代码的临界区，线程需要锁定并等待锁定，他们不知道哪些线程持有锁，而只是知道锁被某个线程持有， 并且他们应该等待取得锁, 而不是去了解哪个线程在同步块内，并请求它们释放锁定。
	4.Java 是基于 Hoare 的监视器的思想。在Java中，所有对象都有一个监视器。线程在监视器上等待，为执行等待，我们需要2个参数：
		1.一个线程
		2.一个监视器(任何对象)

		在 Java 设计中，线程不能被指定，它总是运行当前代码的线程。但是，我们可以指定监视器(这是我们称之为等待的对象)。这是一个很好的设计，因为如果我们可以让任何其他线程在所需的监视器上等待，这将导致“入侵”，导致在设计并发程序时会遇到困难。请记住，在 Java 中，所有在另一个线程的执行中侵入的操作都被弃用了(例如 stop 方法)。


5.ThreadLocal


6.Unsafe类
	https://blog.csdn.net/u012988901/article/details/112999254

#######################################[java IO]#######################################
1.java IO
	IO概念
		流是从一端到另外一端,连接了源头与目的地;IO流可以理解为连接程序与文件/数组/网络连接/数据库
	IO 流分类
		1.按照流向分类
			输入流
			输出流
		2.按处理数据不同分类
			字节流:
				二进制, 可以处理一切文件;包括纯文本,doc,音频,视频等
			字符流:
				文本文件,只能处理纯文本



#######################################[java 锁知识]#######################################

AQS
	1.什么是AQS?
		AQS-->AbstractQueuedSynchronizer  抽象的队列式同步器

	2.它有什么用?
		它定义了一套多线程访问共享资源的同步器框架,许多同步类实现都依赖于它;如常用的ReentrantLock/Semaphore/CountDownLatch

	3.它的基本构成?
	            +------+  prev +-----+       +-----+
	       head |      | <---- |     | <---- |     |  tail
	            +------+       +-----+       +-----+

	    CLH 队列
	    Craing, Landin, Hagersten

	    CLH队列是虚拟的双向队列,虚拟的双向队列即不存在队列实例,仅存在结点之间的关联关系;
	    AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点, 来实现锁的分配;

	4.内部原理?
		就是根据state标志位使用cas更新,如果更新成功,那么便获取了锁;





#######################################[java 网络]#######################################

1.session和cookie有什么区别？
	1.session和session实现是不同的概念
		session是一种抽象概念,一种基于用户与服务端之间的一对一交互,抽象为会话,进而衍生出会话状态,也就是session的概念
		session实现通常需要使用cookie,cookie存储的session_id维持了session的状态;但是coolie并非必须,可以通过重写url的方式来实现一样的效果


2.什么是 XSS 攻击，如何避免？
	XSS 攻击，即跨站脚本攻击（Cross Site Scripting），它是 web 程序中常见的漏洞。
	原理
		攻击者往 web 页面里插入恶意的 HTML 代码（Javascript、css、html 标签等），当用户浏览该页面时，嵌入其中的 HTML 代码会被执行，从而达到恶意攻击用户的目的。如盗取用户 cookie 执行一系列操作，破坏页面结构、重定向到其他网站等。 

3. 什么是 CSRF 攻击，如何避免？
	CSRF：Cross Site Request Forgery（跨站点请求伪造）。
	CSRF 攻击者在用户已经登录目标网站之后，诱使用户访问一个攻击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。

4.TCP与UDP的区别
	网络分层:
		应用层	Http
		传输层	TCP/UDP
		网络层 	IP
		链路层	ARP


	UDP是面向无连接的通讯协议,UDP 数据包括目的端口号和源端信息

	TCP 是面向连接的通讯协议，通过三次握手建立连接，通讯完成时四次挥手
		TCP通信过程:
			三次握手：
				1. 主动发起请求端， 发送 SYN 
				2. 被动建立连接请求端 ， 应答ACK 同时 发送 SYN
				3. 主动发起请求端，发送应答 ACK
				* 标志 TCP 三次握手建立完成。 —— server：Accept() 返回 。— client：Dial() 返回。

			四次挥手：
				1. 主动关闭连接请求端， 发送 FIN
				2. 被动关闭连接请求端 ，应答 ACK
								标志。半关闭完成。 —— close()
				3. 被动关闭连接请求端 ，发送 FIN
				4.  主动关闭连接请求端，应答 ACK
								标志。四次挥手建立完成。 —— close().


4.实现跨域的N种方式
	https://www.cnblogs.com/yzg1/p/5070037.html


5.几种分布式session实现
	https://www.cnblogs.com/williamjie/p/11083788.html
	https://blog.csdn.net/u011213044/article/details/80525997
	1.使用JWT (Json Web Token)
		https://cloud.tencent.com/developer/article/1495531
		使用 JWT Token 储存用户身份，然后再从数据库或者 cache 中获取其他的信息。这样无论请求分配到哪个服务器都无所谓。
			流程上是这样的：
				用户使用用户名密码来请求服务器
				服务器进行验证用户的信息
				服务器通过验证发送给用户一个token
				客户端存储token，并在每次请求时附送上这个token值
				服务端验证token值，并返回数据

			JWT组成:
				Header 头部
				Payload 负载
				Signature 签名


	2.Tomcat + Redis 
		这个其实还挺方便的，就是使用 session 的代码，跟以前一样，还是基于 tomcat 原生的 session 支持即可，然后就是用一个叫做 Tomcat RedisSessionManager 的东西，让所有我们部署的 tomcat 都将 session 数据存储到 redis 即可。

	3.spring session + redis
		因为上面那种 tomcat + redis 的方式好用，但是会严重依赖于web容器，不好将代码移植到其他 web 容器上去，尤其是你要是换了技术栈咋整？比如换成了 spring cloud 或者是 spring boot 之类的呢？
		所以现在比较好的还是基于 Java 一站式解决方案，也就是 spring。人家 spring 基本上承包了大部分我们需要使用的框架，spirng cloud 做微服务，spring boot 做脚手架，所以用 sping session 是一个很好的选择。


#######################################[java 并发编程]#######################################
1.volatile关键字解析
	https://www.cnblogs.com/dolphin0520/p/3920373.html
	内存模型:
		CUP高速缓存,如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。
		如何解决缓存一致性问题?
			1.通过总线加LOCK锁的方式
				在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。
			2.通过缓存一致性协议
				由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。
				所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。

		2种方式都是硬件层面上提供的方式

	并发编程中的三个概念
		1.原子性
			即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
		2.可见性
			可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
		3.有序性
			即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码

	指令重排序
		什么是指令重排序?
			处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。
			指令重排序在单线程的执行结果一致,但是在多线程的情况并


	java内存模型(Java Memory Model, JMM)
		java内存模型规定所有的变量都是存在主存中,每个线程都有自己的工作内存;线程对变量的所有操作都必须在工作内存中进行,而不能直接对主存进行操作,并且每个线程都不能访问其他线程的工作内存;

	volatile关键字
		1.不保证原子性

		2.保证可见性
			当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
		3.一定程度保证有序性
			在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。
		　　volatile关键字禁止指令重排序有两层意思：
		　　1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
		　　2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。

	volatile的原理和实现机制
		观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”	lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：
		　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
		　　2）它会强制将对缓存的修改操作立即写入主存；
		　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。


2.synchronized 关键字解析
	https://www.cnblogs.com/lanweijava/p/9435138.html
	1.用法
		1.同步方法
			对于同步方法,JVM采用的ACC_SYNCHRONIZED标记符来实现同步

			方法级的同步是隐式的。同步方法的常量池中会有一个ACC_SYNCHRONIZED标志。当某个线程要访问某个方法的时候，会检查是否有ACC_SYNCHRONIZED，如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁。这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。

		2.同步代码块
			对于同步代码块,JVM采用的monitorenter和monitorexit两个指令来实现同步

			同步代码块使用monitorenter和monitorexit两个指令实现。可以把执行monitorenter指令理解为加锁，执行monitorexit理解为释放锁。 每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁（执行monitorenter）后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁（执行monitorexit指令）的时候，计数器再自减。当计数器为0的时候。锁将被释放，其他线程便可以获得锁。

		无论是ACC_SYNCHRONIZED还是monitorenter、monitorexit都是基于Monitor实现的，在Java虚拟机(HotSpot)中，Monitor是基于C++实现的，由ObjectMonitor实现。

		ObjectMonitor类中提供了几个方法，如enter、exit、wait、notify、notifyAll等。sychronized加锁的时候，会调用objectMonitor的enter方法，解锁的时候会调用exit方法。（关于Monitor详见深入理解多线程（四）—— Moniter的实现原理）

		前面介绍了synchronized的用法、原理以及对并发编程的作用。是一个很好用的关键字。
		synchronized其实是借助Monitor实现的，在加锁时会调用objectMonitor的enter方法，解锁的时候会调用exit方法。事实上，只有在JDK1.6之前，synchronized的实现才会直接调用ObjectMonitor的enter和exit，这种锁被称之为重量级锁。
		所以，在JDK1.6中出现对锁进行了很多的优化，进而出现轻量级锁，偏向锁，锁消除，适应性自旋锁，锁粗化(自旋锁在1.4就有，只不过默认的是关闭的，jdk1.6是默认开启的)，这些操作都是为了在线程之间更高效的共享数据 ，解决竞争问题。

3.JVM 锁优化
	https://www.cnblogs.com/jhxxb/p/10975607.html
	https://www.cnblogs.com/virgosnail/p/9681013.html
	JDK1.6版本花费了大量精力去实现各种锁优化，如适应性自旋，锁消除，锁粗化，轻量级锁，偏向锁等，这些技术都是为了在线程期间更高效的共享数据，以及解决竞争问题。

	2. 自旋锁与自适应自旋
	　　传统的互斥锁对性能最大的影响是阻塞的实现，线程的挂起和恢复需要转入内核态中完成，相当影响效率。
	　　多线程场景下线程之间通过抢占CPU时间分片进行任务执行，有可能持有锁的线程很快就会释放锁，此时让后面的线程执行一个忙循环进行等待。这就是自旋锁。
	　　自选次数默认为10次，可使用 -XX：PreblockSpin参数来更改。
	　　jdk1.6 加入了自适应自旋锁，这意味着自旋时间不再是固定的，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态来决定。随着JVM的运行，自旋时间的预测也将更加准确。

	3. 锁消除
　　   锁消除是指在JVM即时编译器运行时，在对代码进行同步时，对检测到不存在共享数据竞争的锁进行消除。
	4. 锁粗化
　　    如果一系列的连续操作都对同一个对象反复加锁和解锁，则将会把同步的范围粗化到整个操作序列的外部，这样只需要加一次锁就行了。
	5. 锁升级
			# 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁
		这四种锁是指锁的状态，专门针对synchronized的;synchronized是悲观锁,在操作同步资源的时候会先加锁;这把锁就在对象头里
		- Java对象头
			- 1.mark word (标记字段)
		Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以        Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存        储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。

			- 2.klass point (类型指针)
		对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例

		- monitor
			Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内       部锁或者Monitor锁。

			Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个       被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这       个线程占用。


		所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。

		- 无锁
			无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。
		    无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的
		    
		- 偏向锁
			 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。
			
		- 轻量级锁
		    是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能

		- 重量级锁
		    若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁



#######################################[java JVM]#######################################
1.Java 类加载过程？说一下类加载的执行过程？
	https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483934&idx=1&sn=41c46eceb2add54b7cde9eeb01412a90&chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&scene=21#wechat_redirect
	类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的 Class对象， Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。

	类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误

	加载.class文件的方式
		1.从本地系统中直接加载
		2.通过网络下载.class文件
		3.从zip，jar等归档文件中加载.class文件
		4.从专有数据库中提取.class文件
		5.将Java源文件动态编译为.class文件

	类的生命周期:
		其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。
		1.加载
			查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：
				1.通过一个类的全限定名来获取其定义的二进制字节流。
				2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
				3.在Java堆中生成一个代表这个类的 java.lang.Class对象，作为对方法区中这些数据的访问入口。
			相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。
			加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。
		2.连接
			1.验证
				目的:
					确保被加载的类的正确性
				验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：
					1.文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
					2.元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。
					3.字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
					4.符号引用验证：确保解析动作能正确执行。
				验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

			2.准备
				目的:
					为类的 静态变量分配内存，并将其初始化为默认值
				准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：
					1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
					2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。
						假设一个类变量的定义为： public static int value = 3；
						那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的 public static指令是在程序编译后，存放于类构造器 <clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行

							这里还需要注意如下几点：
								1.对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。
								2.对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。
								3.对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。
								4.如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。
					3.如果类字段的字段属性表中存在 ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值
						假设上面的类变量value被定义为： public static final int value = 3；
						编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据 ConstantValue的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中

			3.解析
				目的:
					把类中的符号引用转换为直接引用
				解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。

				直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

			4.初始化
				初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：
					①声明类变量是指定初始值
					②使用静态代码块为类变量指定初始值

				JVM初始化步骤
					1、假如这个类还没有被加载和连接，则程序先加载并连接该类
					2、假如该类的直接父类还没有被初始化，则先初始化其直接父类
					3、假如类中有初始化语句，则系统依次执行这些初始化语句

				类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：
					1.创建类的实例，也就是new的方式
					2.访问某个类或接口的静态变量，或者对该静态变量赋值
					3.调用类的静态方法
					4.反射（如 Class.forName(“com.shengsiyuan.Test”)）
					5.初始化某个类的子类，则其父类也会被初始化
					6.Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类

			5.结束生命周期
				在如下几种情况下，Java虚拟机将结束生命周期
					1.执行了 System.exit()方法
					2.程序正常执行结束
					3.程序在执行过程中遇到了异常或错误而异常终止
					4.由于操作系统出现错误而导致Java虚拟机进程终止





	类加载器:
		启动类加载器： BootstrapClassLoader，
			负责加载存放在 JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被 -Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被 BootstrapClassLoader加载）。启动类加载器是无法被Java程序直接引用的。
		扩展类加载器： ExtensionClassLoader，
			该加载器由 sun.misc.Launcher$ExtClassLoader实现，它负责加载 JDK\jre\lib\ext目录中，或者由 java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。
		应用程序类加载器： ApplicationClassLoader，
			该类加载器由 sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。


	JVM类加载机制
		1.全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入
		2.父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类
		3.缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效


	为什么要用父类委托?
		双亲委派的原因：
		（1）主要是为了安全性，避免用户自己编写的类动态替换 Java的一些核心类，比如 String。
		（2）同时也避免了类的重复加载，因为 JVM中区分不同类，不仅仅是根据类名，相同的 class文件被不同的 ClassLoader加载就是不同的两个类


2.描述一下JVM加载class文件的原理机制
	https://www.cnblogs.com/williamjie/p/11167920.html
	https://www.cnblogs.com/Qian123/p/5707562.html#_labelTop

	JVM (Java Virtual Machine) 
	Java Virtual Machine --> 操作系统(Linux, Windows) --> 硬件系统(如Intel体系, SPAC等)

	JVM 组成部分
		1.class loader 类加载器
			类加载器的作用是加载类文件到内存;加载的类必须符合Class文件的结构;class loader只负责加载,至于能不能运行,则不是它负责,那是由Execution Engine负责
			类加载过程:
				1.加载
				2.验证
				3.解析
				4.初始化
				5.结束生命周期

		2.Execution Engine 执行引擎
			执行引擎也叫做解释器(Interpreter) ，负责解释命令，提交操作系统执行。

		3.Native Interface 本地接口
			本地接口的作用是融合不同的编程语言为Java 所用，它的初衷是融合C/C++ 程序，Java 诞生的时候是C/C++ 横行的时候，要想立足，必须有一个聪明的、睿智的调用C/C++ 程序，于是就在内存中专门开辟了一块区域处理标记为native 的代码，它的具体做法是Native Method Stack 中登记native 方法，在Execution Engine 执行时加载native libraies 。目前该方法使用的是越来越少了，除非是与硬件有关的应用，比如通过Java 程序驱动打印机，或者Java 系统管理生产设备，在企业级应用中已经比较少见，因为现在的异构领域间的通信很发达，比如可以使用Socket 通信，也可以使用Web Service 等等，不多做介绍。

		4.Runtime data area 运行数据区
			运行数据区是整个JVM 的重点。我们所有写的程序都被加载到这里，之后才开始运行，Java 生态系统如此的繁荣，得益于该区域的优良自治。

		整个JVM 框架由加载器加载文件，然后执行器在内存中处理数据，需要与异构系统交互是可以通过本地接口进行，瞧，一个完整的系统诞生了！


	类加载器的原理
		Java中所有的类,都需要加载到JVM中才能运行.类加载器本身也是一个类,而它的工作就是把class文件从硬盘读取到内存中,在写程序的时候,我们几乎不用担心类的加载,因为这些类都是隐式加载;
			类装载的方式有两种:
				1.隐式加载
					程序在运行过程中当碰到new等方式生成对象时,隐式调用类加载器加载对应类到jvm中
				2.显示加载
					如反射,通过class.forname()

     		Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。

     	Java的类加载器分成三种，对应Java的三种类: （java中的类大致分为三种：   1.系统类   2.扩展类 3.由程序员自定义的类 ）
     		1.Bootstrap Loader  // 负责加载系统类 (指的是内置类，像是String，对应于C#中的System类和C/C++标准库中的类)
     		2.负责加载扩展类(就是继承类和实现类)
     		3.负责加载应用类(程序员自定义的类)

3.Java 内存结构
	https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483949&idx=1&sn=8b69d833bbc805e63d5b2fa7c73655f5&chksm=ebf6da52dc815344add64af6fb78fee439c8c27b539b3c0e87d8f6861c8422144d516ae0a837&scene=21#wechat_redirect

	JMM (Java Memory Model) Java 内存模型

	JVM 的内存结构主要分成三大块
		1.堆内存
			年轻代 : 老年代 = 1 : 2
			1.年轻代
				Eden : To Survivor : From Survivor = 8 : 1 : 1
				1.Eden空间
				2.To Survivor空间
				3.From Survivor空间
			2.老年代
		2.方法区(non heap ps: 为了区分堆,方法区也叫非堆)
			方法区存储类信息、常量、静态变量等数据，是线程共享的区域，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)；
		3.栈	
			栈又分为java虚拟机栈和本地方法栈主要用于方法的执行

	JVM 参数
		-Xms设置堆的最小空间大小。
		-Xmx设置堆的最大空间大小。
		-XX:NewSize设置新生代最小空间大小。
		-XX:MaxNewSize设置新生代最大空间大小。
		-XX:PermSize设置永久代最小空间大小。
		-XX:MaxPermSize设置永久代最大空间大小。
		-Xss设置每个线程的堆栈大小。

	堆(heap)
		堆是Java 虚拟机中所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
		Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。

		根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。

		如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

	方法区（Method Area）
		方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。

		Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。

		根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

	程序计数器（Program Counter Register）
		程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

		由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

		如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。

		此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

	JVM栈（JVM Stacks）
		与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

		局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。

		其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

		在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。

	本地方法栈（Native Method Stacks）
		本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。


4.垃圾收集算法
	https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483986&idx=1&sn=a2d7c9f2e73dfcc938a3ec934b3ad3a4&chksm=ebf6da2ddc81533beb5e6fb54c872b5f79524d0780c484718a57ca0712916cd67bda7dee4073&scene=21#wechat_redirect
	垃圾收集 Garbage Collection 简称GC; 在JVM中,程序计数器, 虚拟机栈,本地方法栈都随着线程生随着线程灭;栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的.

	判断对象存活
		判断一个对象有有两种方式
			1.引用计数
				每个对象都有一个引用计数属性,新增一个引用时计数加1,引用释放时减1;计数为0的时候可以回收,此方法简单,但是无法解决循环引用的问题
			2.可达性算法
				从GC Roots开始向下搜索,搜索走过的链成为引用链,当一个对象到GC Roots没有任何引用链时,证明此对象是不可用的,不可达对象

				在Java语言里面, GC Roots包括
					1.虚拟机栈中引用的对象
					2.方法区中静态属性实体引用的属性
					3.方法区中常量引用的对象
					4.本地方法栈中JNI引用的对象
	垃圾收集算法:
		1.标记-清除
			首先标记需要回收的对象,在标记完成后,统一回收被标记的对象
			缺点:
				1.效率不高
				2.回收的内存不连续,回收后会产生大量不连续的空间
		2.复制算法
			“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

		3.标记-整理
			标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

	分代收集算法
		“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清除”或“标记-整理”算法来进行回收。


	垃圾收集器
		如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现

		1.CMS (Concurrent Mark Sweep)
			CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。
			使用的是“标记-清除”算法

				执行过程:
					1.初始标记：标记一下GC Roots能直接关联到的对象，会"Stop The World"。
					2.并发标记：GC Roots Tracing，可以和用户线程并发执行。
					3.重新标记：标记期间产生的对象存活的再次判断，修正对这些对象的标记，执行时间相对并发标记短，会“Stop The World”。
					4.并发清除：清除对象，可以和用户线程并发执行。
			
				优点: 并发收集、低停顿
				缺点: 产生大量空间碎片、并发阶段会降低吞吐量
		2.G1
			G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点：
				1.空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。
				2.可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。

					上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。

				收集步骤:
					1、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)
					2、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。
					3、Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。
					4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。
					5、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。
					6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。
		3.ZGC
			染色指针等

	各类垃圾回收器的比较
		https://blog.csdn.net/guorui_java/article/details/108405844


6.DGC (Distribution Garbage Collection) 分布式垃圾回收
	概念：  
        1)Java虚拟机中，一个远程对象不仅会被本地虚拟机内的变量引用，还会被远程引用。  
        2)只有当一个远程对象不受到任何本地引用和远程引用，这个远程对象才会结束生命周期。  
      
    说明：  
        1)服务端的一个远程对象在3个地方被引用：  
            1>服务端的一个本地对象持有它的本地引用  
            2>服务端的远程对象已经注册到rmiregistry注册表中，也就是说，rmiregistry注册表持有它的远程引用。  
            3>客户端获得远程对象的存根对象，也就是说，客户端持有它的远程引用。  
        2)服务端判断客户端是否持有远程对象引用的方法：  
            1>当客户端获得一个服务端的远程对象的存根时，就会向服务器发送一条租约(lease)通知，以告诉服务器自己持有了这个远程对象的引用了。  
            2>客户端定期地向服务器发送租约通知，以保证服务器始终都知道客户端一直持有着远程对象的引用。  
            3>租约是有期限的，如果租约到期了，服务器则认为客户端已经不再持有远程对象的引用了。


7.Java 存在内存泄露吗?
	所谓内存泄露就是指一个不再被程序使用的对象或者变量一直被占据在内存中;
	内存泄露的2种情况
		1、长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露。
			尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是Java中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是Java中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。

		2、当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露


8.强引用，软引用，弱引用和虚引用的区别与用法
	https://blog.csdn.net/junjunba2689/article/details/80601729
	从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用
	1.强引用
		以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。
	2.软引用（SoftReference）
		如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。

		软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。
			（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建
			（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出这时候就可以使用软引用
	3.弱引用（WeakReference）
		如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。
		弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。

		如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象。
			这个引用不会在对象的垃圾回收判断中产生任何附加的影响。
	4.虚引用（PhantomReference）
		“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

		特别注意，在实际程序设计中一般很少使用弱引用与虚引用，使用软用的情况较多，这是因为软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。
		

	总结：

		强引用：
			String str = “abc”;
			list.add(str);
		软引用：
			如果弱引用对象回收完之后，内存还是报警，继续回收软引用对象
		弱引用：
			如果虚引用对象回收完之后，内存还是报警，继续回收弱引用对象
		虚引用：
			虚拟机的内存不够使用，开始报警，这时候垃圾回收机制开始执行System.gc(); String s = “abc”;如果没有对象回收了， 就回收没虚引用的对象

9.内存分配与回收策略及MinorGC、MajorGC、FullGC介绍		
	https://blog.csdn.net/u012988901/article/details/100630491
	对象的内存分配，往大方向讲，就是在堆上分配〔但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中。
		对象优先分配在Eden区，当Eden区可用空间不够时会进行MinorGC

		大对象直接进入老年代：大对象即需要大量连续内存空间的对象（例如很长的字符串及数组）。虚拟机提供了一个-XX:PretenureSizeThreshoId参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在Eden区及两个区之间发生大量的内存复制。注意PretenureSizeThreshoId参数只对Serial和ParNew两款收集器有效。

		长期存活的对象将进入老年代：虚拟机给每个对象定义了一个对象年龄（Age）计数器（存在于对象头中）。如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survwor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshoId设置。

		动态年龄判断：为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进人老年代，无须等到MaxTenuringThreshoId中要求的年龄。

		 空间分配担保：在发生Minor GC之前，虚拟机会先检查Survivor空间是否够用，如果够用则直接进行Minor GC。否则进行检查老年代最大连续可用空间是否大于新生代的总和，假如大于，那么这个时候发生Minor GC是安全的。假如不大于，那么需要判断HandlePromotionFailure设置是否允许担保失败。假如允许，则继续判定老年代最大可用的连续空间是否大于平均晋升到老年代对象的平均值，如果大于，这个时候可以发生Minor GC ，如果小于或者设置HandlePromotionFailure不允许担保失败，则需要做一次Full GC。通常会把HandlePromotionFailure开关打开，以减少Full GC。


	对象何时进入新生代、老年代
		新分配的对象一般是直接进入新生代的。但是如果出现以下的情况，会让对象进入老年代。

		1.新分配的对象占用空间大于-XX:PretenureSizeThreshold时直接分配到老年代
		2.MinorGC的时候，Survivor中的内存不足了，允许分配担保时会进入老年代。
		3.MinorGC的时候，对象的年龄大于-XX:MaxTenuringThreshold（默认为15）时，进入老年代。对象年龄存在于对象头中，占4bit。
		4.当进行MinorGC的时候，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进人老年代。

	Minor GC
		从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC，也叫Young GC。因为Java对象大多具备朝生夕死的特征，所以MinorGC非常频繁，一般回收速度也比较快。一般采用复制算法。
		Minor GC触发条件

		Eden区域满了
		新生对象需要分配到新生代的Eden，当Eden区的内存不够时需要进行MinorGC

	Major GC/Full GC：
		MajorGC：是清理老年代，Major GC发生过程常常伴随一次Minor

		FullGC：Full GC可以看做是Major GC+Minor GC共同进行的一整个过程，是清理整个堆空间（包括年轻代和老年代，这里不包含永久代，因为永久代在JDK7之前包含方法区，是一块与堆分离的区域；JDK7将静态变量从永久代移到堆中；JDK8则完全取消永久代，方法区存在元空间MetaSpace中，虽然与堆共享一块内存，逻辑上可以认为在堆中，但仍然与堆不相连）。Full GC的速度一般会比 Minor GC慢10倍以上。一般用的是标记整理和标记清除算法

		Full GC触发条件

		上面Minor GC时介绍中Survivor空间不足时，判断是否允许担保失败，如果不允许则进行Full GC。如果允许，并且每次晋升到老年代的对象平均大小>老年代最大可用连续内存空间，也会进行Full GC。
		MinorGC后存活的对象超过了老年代剩余空间
		方法区内存不足时
		System.gc()，可用通过-XX:+ DisableExplicitGC来禁止调用System.gc
		CMS GC异常，CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，会触发Full GC


10.JDK和JRE的区别是什么？
	JDK:java开发工具包,包含了JRE、编译器和其它工具（如：javaDOc、java调试器)

	JRE:java运行环境,包含java虚拟机和java程序所需的核心类库。

	如果只是想跑java程序，那么只需安装JRE，如果要写java程序并且运行，那就需要JDK了。


11.系统调优(full GC 和 CPU 100%)		
	https://www.cnblogs.com/williamjie/p/11168533.html


12.java内存区域
	https://www.cnblogs.com/williamjie/p/11083895.html
	1.java的内存区域 1.8
		1.虚拟机栈
			栈帧
				1.局部变量表
				2.操作栈数
				3.动态链接
				4.方法的返回值
		2.本地方法栈
		3.程序计数器
		4.元空间
			元空间使用的是直接内存
			https://www.jianshu.com/p/a6f19189ec62
			metaSpace主要由两大部分组成
				1.Klass MetaSpace
					1.Klass Metaspace就是用来存klass的，就是class文件在jvm里的运行时数据结构（不过我们看到的类似A.class其实是存在heap里的，是java.lang.Class的对象实例）。
					2.这部分默认放在Compressed Class Pointer Space中，是一块连续的内存区域，紧接着Heap，和之前的perm一样。通过-XX:CompressedClassSpaceSize来控制这块内存的大小，默认是1G。
					3.Compressed Class Pointer Space不是必须有的，如果设置了-XX:-UseCompressedClassPointers，或者-Xmx设置大于32G，就不会有这块内存，这种情况下klass都会存在NoKlass Metaspace里
				2.NoKlass MetaSpace
					1.NoKlass Metaspace专门来存klass相关的其他的内容，比如method，constantPool等，可以由多块不连续的内存组成。
					2.这块内存是必须的，虽然叫做NoKlass Metaspace，但是也其实可以存klass的内容，上面已经提到了对应场景。
					3.NoKlass Metaspace在本地内存中分配。

			指针压缩:
				1.在64平台上默认打开
				2.设置-XX:+UseCompressedOops压缩对象指针， oops指的是普通对象指针(ordinary object pointers)， 会被压缩成32位。
				3.设置-XX:+UseCompressedClassPointers压缩类指针，会被压缩成32位。

			MetaSpace的内存管理
				1.在metaspace中，类和其元数据的生命周期与其对应的类加载器相同，只要类的类加载器是存活的，在Metaspace中的类元数据也是存活的，不能被回收。
				2.每个加载器有单独的存储空间。
				3.省掉了GC扫描及压缩的时间。
				4.当GC发现某个类加载器不再存活了，会把对应的空间整个回收。

		5.堆
			常量池
				1.字面量
					1.文本字符串
					2.被声明为final的常量值
					3.基本数据类型的值
					4.其它
				2.符号引用
					1.类和结构完全限定名
					2.字段名称和描述符
					3.方法名称和描述符

			直接内存:
				直接内存并不是虚拟机运行时数据区的一部分,也不是虚拟机规范中定义的内存区域,但是这部分内存也被频繁的使用;而且可能导致OutOfMemoryError异常出现


	2.java对象的创建过程(5步)
		1.类加载检查
			 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
		2.分配内存
			在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

			内存分配的两种方式:
				1.指针碰撞
					1.使用场景: 堆内存规整(即没有内存碎片的情况)
					2.原理: 用过的内存全部整合到一边,没有用过的内存整合到另一边,中间有一个分界值指针,只需要向着没有用过的方向将该指针移动对象内存大小位置即可
					3.GC收集器: serial, partNew
				2.空闲列表
					1.使用场景: 堆内存不规整
					2.原理: 虚拟机会维护一个列表,该列表中会记录哪些内存块是可用的;在分配的时候,找一块足够大的内存块去划分给对象实例,最后更新记录
					3.GC收集器: CMS

			内存分配并发问题:
				在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：
					CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。•TLAB： 为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配
		3.初始化零值
			内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
		4.设置对象头
			初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。
		5.执行init方法
			在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。


		对象的内存布局:
			在hotSpot虚拟机中,对象在内存中的布局可以分为3块区域:
				1.对象头
					1.存储自身的运行时数据(哈希码、GC分代年龄、锁状态标志等等)
					2.类型指针
						即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。

				2.实例数据
					实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。
				3.对象填充 
					对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。 因为Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全

	3.对象访问的两种方式(句柄和直接指针两种方式)
		建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有①使用句柄和②直接指针两种：
			1.句柄： 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；
			2.直接指针： 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。

		这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。








#######################################[java 知识分享链接]#######################################


同事分享,脑图
	https://naotu.baidu.com/file/b61fc4ab88185e5aba9508dacce4257d?token=6f7893f740536c9a
	https://naotu.baidu.com/file/aaf627cd4354acb836e1ad6a83faacba?token=71b7292f998b60e0



java基础知识汇总-网络分享
    https://blog.csdn.net/u013411339/article/details/87957648


美团技术团队
    https://tech.meituan.com/


AQS
	美团技术文章
	https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html

	AQS详解
	https://www.cnblogs.com/waterystone/p/4920797.html