1.Java 类加载过程？说一下类加载的执行过程？
	https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483934&idx=1&sn=41c46eceb2add54b7cde9eeb01412a90&chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&scene=21#wechat_redirect
	类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的 Class对象， Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。

	类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误

	加载.class文件的方式
		1.从本地系统中直接加载
		2.通过网络下载.class文件
		3.从zip，jar等归档文件中加载.class文件
		4.从专有数据库中提取.class文件
		5.将Java源文件动态编译为.class文件

	类的生命周期:
		其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。
		1.加载
			查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：
				1.通过一个类的全限定名来获取其定义的二进制字节流。
				2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
				3.在Java堆中生成一个代表这个类的 java.lang.Class对象，作为对方法区中这些数据的访问入口。
			相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。
			加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。
		2.连接
			1.验证
				目的:
					确保被加载的类的正确性
				验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：
					1.文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
					2.元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。
					3.字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
					4.符号引用验证：确保解析动作能正确执行。
				验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

			2.准备
				目的:
					为类的 静态变量分配内存，并将其初始化为默认值
				准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：
					1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
					2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。
						假设一个类变量的定义为： public static int value = 3；
						那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的 public static指令是在程序编译后，存放于类构造器 <clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行

							这里还需要注意如下几点：
								1.对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。
								2.对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。
								3.对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。
								4.如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。
					3.如果类字段的字段属性表中存在 ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值
						假设上面的类变量value被定义为： public static final int value = 3；
						编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据 ConstantValue的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中

			3.解析
				目的:
					把类中的符号引用转换为直接引用
				解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。

				直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

			4.初始化
				初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：
					①声明类变量是指定初始值
					②使用静态代码块为类变量指定初始值

				JVM初始化步骤
					1、假如这个类还没有被加载和连接，则程序先加载并连接该类
					2、假如该类的直接父类还没有被初始化，则先初始化其直接父类
					3、假如类中有初始化语句，则系统依次执行这些初始化语句

				类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：
					1.创建类的实例，也就是new的方式
					2.访问某个类或接口的静态变量，或者对该静态变量赋值
					3.调用类的静态方法
					4.反射（如 Class.forName(“com.shengsiyuan.Test”)）
					5.初始化某个类的子类，则其父类也会被初始化
					6.Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类

			5.结束生命周期
				在如下几种情况下，Java虚拟机将结束生命周期
					1.执行了 System.exit()方法
					2.程序正常执行结束
					3.程序在执行过程中遇到了异常或错误而异常终止
					4.由于操作系统出现错误而导致Java虚拟机进程终止





	类加载器:
		启动类加载器： BootstrapClassLoader，
			负责加载存放在 JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被 -Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被 BootstrapClassLoader加载）。启动类加载器是无法被Java程序直接引用的。
		扩展类加载器： ExtensionClassLoader，
			该加载器由 sun.misc.Launcher$ExtClassLoader实现，它负责加载 JDK\jre\lib\ext目录中，或者由 java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。
		应用程序类加载器： ApplicationClassLoader，
			该类加载器由 sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。


	JVM类加载机制
		1.全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入
		2.父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类
		3.缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效





2.java内存区域
	https://blog.csdn.net/l1394049664/article/details/81486470
	1.java的内存区域 1.8
		1.虚拟机栈
			栈帧
				1.局部变量表
				2.操作栈数
				3.动态链接
				4.方法的返回值
		2.本地方法栈
		3.程序计数器
		4.元空间
			元空间使用的是直接内存
			https://www.jianshu.com/p/a6f19189ec62
			metaSpace主要由两大部分组成
				1.Klass MetaSpace
					1.Klass Metaspace就是用来存klass的，就是class文件在jvm里的运行时数据结构（不过我们看到的类似A.class其实是存在heap里的，是java.lang.Class的对象实例）。
					2.这部分默认放在Compressed Class Pointer Space中，是一块连续的内存区域，紧接着Heap，和之前的perm一样。通过-XX:CompressedClassSpaceSize来控制这块内存的大小，默认是1G。
					3.Compressed Class Pointer Space不是必须有的，如果设置了-XX:-UseCompressedClassPointers，或者-Xmx设置大于32G，就不会有这块内存，这种情况下klass都会存在NoKlass Metaspace里
				2.NoKlass MetaSpace
					1.NoKlass Metaspace专门来存klass相关的其他的内容，比如method，constantPool等，可以由多块不连续的内存组成。
					2.这块内存是必须的，虽然叫做NoKlass Metaspace，但是也其实可以存klass的内容，上面已经提到了对应场景。
					3.NoKlass Metaspace在本地内存中分配。

			指针压缩:
				1.在64平台上默认打开
				2.设置-XX:+UseCompressedOops压缩对象指针， oops指的是普通对象指针(ordinary object pointers)， 会被压缩成32位。
				3.设置-XX:+UseCompressedClassPointers压缩类指针，会被压缩成32位。

			MetaSpace的内存管理
				1.在metaspace中，类和其元数据的生命周期与其对应的类加载器相同，只要类的类加载器是存活的，在Metaspace中的类元数据也是存活的，不能被回收。
				2.每个加载器有单独的存储空间。
				3.省掉了GC扫描及压缩的时间。
				4.当GC发现某个类加载器不再存活了，会把对应的空间整个回收。

		5.堆
			常量池
				1.字面量
					1.文本字符串
					2.被声明为final的常量值
					3.基本数据类型的值
					4.其它
				2.符号引用
					1.类和结构完全限定名
					2.字段名称和描述符
					3.方法名称和描述符

			直接内存:
				直接内存并不是虚拟机运行时数据区的一部分,也不是虚拟机规范中定义的内存区域,但是这部分内存也被频繁的使用;而且可能导致OutOfMemoryError异常出现


	2.java对象的创建过程(5步)
		1.类加载检查
			 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
		2.分配内存
			在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

			内存分配的两种方式:
				1.指针碰撞
					1.使用场景: 堆内存规整(即没有内存碎片的情况)
					2.原理: 用过的内存全部整合到一边,没有用过的内存整合到另一边,中间有一个分界值指针,只需要向着没有用过的方向将该指针移动对象内存大小位置即可
					3.GC收集器: serial, partNew
				2.空闲列表
					1.使用场景: 堆内存不规整
					2.原理: 虚拟机会维护一个列表,该列表中会记录哪些内存块是可用的;在分配的时候,找一块足够大的内存块去划分给对象实例,最后更新记录
					3.GC收集器: CMS

			内存分配并发问题:
				在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：
					CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。•TLAB： 为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配
		3.初始化零值
			内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
		4.设置对象头
			初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。
		5.执行init方法
			在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。


		对象的内存布局:
			在hotSpot虚拟机中,对象在内存中的布局可以分为3块区域:
				1.对象头
					1.存储自身的运行时数据(哈希码、GC分代年龄、锁状态标志等等)
					2.类型指针
						即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。

				2.实例数据
					实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。
				3.对象填充 
					对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。 因为Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全

	3.对象访问的两种方式(句柄和直接指针两种方式)
		建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有①使用句柄和②直接指针两种：
			1.句柄： 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；
			2.直接指针： 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。

		这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。




