2020-09-15 13:36
开始spring源码深度解析的阅读,此书在之前已经粗略阅读过一次;
对于专业书,我一般的处理方式都是先读一遍,然后再读一次,二次阅读的过程针对自己不懂的地方仔细的阅读以及理解
这样可以达到很好的理解知识的结果,但其实我渐渐觉得自己在编程基础以及英语阅读上的障碍;其实还是要更加的注重这两方面的知识


Spring整体架构
	Spring架构体系
		Spring是一个分层架构,它包含一系列的功能要素,并被分成大约20个模块
			1.Core Container (容器核心)
				1.core 	Core模块主要包含了Spring框架的基本工具类,Spring的其它组件都要用到这个包里的类,Core是其他组件的基本核心
				2.Beans 	Beans模块是所有的应用都要的,它包含访问配置文件,创建和管理bean以及进行Inversion Of Control/Dependency Injection (IOC/DI)操作所相关的类
				3.Context Context模块构建与Core与Beans模块的基础上,提供了一种类似JNDI注册器的框架式的访问对象的方法,Context模块继承了Beans的特性,为Spring核心提供了大量的扩展,添加了国际化支持(资源绑定),事件传播,资源加载,和Context透明创建的支持,Context模块也同时支持一些javaEE的特性,例如EJB,JMX和基础的远程处理;ApplicationContext接口是Context模块的关键
				4.Expression Language	Expression Language模块提供了强大的表达式语言,用于在运行时查询和操作对象;它是JSP2.1规范中定义的unifed expression language的扩展

			2.Data Access/Integration
				1.JDBC JDBC模块提供了一个抽象层,这个模块包含了Spring对JDBC数据访问进行访问和封装的所有类
				2.ORM ORM模块为流行的对象-关系映射API,如JPA,JDO,Hibernate,iBatis等,提供了一个交互层,利用ORM包,可以混合使用所有Spring提供的特性进行O/R映射
				3.OXM OXM模块提供了一个对Object/XML映射的抽象层,Object/XML映射实现包括JAXB,Castor,XMLBeans,JiBX,XStream
				4.JMS JMS模块主要包含了一些制造和消费消息的特性
				5.Transaction Transaction模块支持编程和声明式事务管理,这些事务类必须实现特定的接口,并对所有的POJO都适用

			3.Web
				1.Web Web模块提供了基础面向Web的继承特性
				2.Web-Servlet Web-Servlet模块改模块包含了Spring的MVC(Model View Controller)实现,
				3.Web-Struts Web-Struts模块提供了对Struts的支持,该支持在Spring3.0中已被弃用
				4.Web-Porlet Web-Porlet模块提供了用于Porlet环境和Web-Servlet模块的MVC实现

			4.AOP
				1.Aspects Aspects模块提供了对AspectsJ的支持
				2.Instrumentation Instrumentation模块提供了class instrumentation支持和classloader实现,使得可以在特定的应用服务器上使用

			5.Test
				1.Test Test模块支持使用JUnit和TestNG对Spring组件进行测试


	Spring结构组成
		Beans包的层级结构

			1.核心类介绍
				DefaultListableBeanFactory
					XmlBeanFactory继承自DefaultListableBeanFactory,而DefaultListableBeanFactory是整个bean加载的核心部分,是Spring加载bean的默认实现,而对于XmlBeanFactory与DefaultListableBeanFactory不同的地方其实是在XmlBeanFactory中使用了自定义XML读取器XmlBeanDefinitionReader

					DefaultListableBeanFactory继承了AbstractAutowireCapableBeanFactory并实现了ConfigurableListableBeanFactory以及BeanDefinitionRegistry接口

					1.AliasRegistry		定义对alias的简单增删改查操作
					2.SimpleAliasRegistry	主要使用map作为alias的缓存,并对接口AliasRegistry进行实现
					3.SingletonBeanRegistry	定义对单例bean的注册和获取
					4.BeanFactory 	定义获取bean以及bean的各种属性
					5.DefaultSingletonBeanRegistry 	对接口SingletonBeanRegistry各函数的实现
					6.HierarchicalBeanFactory	继承BeanFactory,也就是在BeanFactory定义的功能的基础上增加了对parentBeanFactory的支持
					7.BeanDefinitionRegistry	定义对BeanDefinition的各种增删改查
					8.FactoryBeanRegistrySupport	在DefaultSingletonBeanRegistry基础上增加了FactoryBean的特殊处理功能
					9.ConfigurableBeanFactory	提供了配置Factory的各种方法
					10.ListableBeanFactory 	根据各种条件获取bean的配置清单
					11.AbstractBeanFactory 	综合FactoryBeanRegistrySupport和ConfigurableBeanFactory的功能
					12.AutowireCapableBeanFactory 	提供创建bean,自动注入,初始化以及应用bean的后置处理器
					13.AbstractAutowireCapableBeanFactory 	综合AbstractBeanFactory并对接口AutowireCapableBeanFactory进行实现
					14.ConfigurableListableBeanFactory	beanFactory配置清单,指定忽略类型以及接口等
					15.DefaultListableBeanFactory 	综合上述所有功能,主要是对bean注册后的处理

				XmlBeanFactory对DefaultListableBeanFactory进行了扩展,主要用于从XML文档中读取BeanDefinition,对于注册及获取bean都是使用从父类DefaultListableBeanFactory继承的方法实现,而唯独和父类不同的个性化实现就是增加了XmlBeanDefinitionReader类型的reader属性,在XmlBeanFactory中主要使用了reader属性对资源文件进行读取和注册

				XmlBeanDefinitionReader
					XML配置文件的读取是Spring中重要的功能,因为Spring的大部分功能都是以配置作为切入点的
					1.ResourceLoader	定义资源加载器,主要应用于根据给定的资源文件地址返回对应的Resource
					2.BeanDefinitionReader 	主要定义资源文件读取并转换为BeanDefinition的各个功能
					3.EnvironmentCapable	定义获取Environment的方法
					4.DocumentLoader	定义从资源文件加载到转换为Document的功能
					5.AbstractBeanDefinitionReader	对EnvironmentCapable,BeanDefinitionReader类定义的功能进行实现
					6.BeanDefinitionParserDelegate	定义解析Element的各种方法

					1.通过继承自AbstractBeanDefinitionReader中的方法,来使用ResourceLoader将资源文件路径转换成对应的Resource文件
					2.通过DocumentLoader对resource文件进行转换,将Resource文件转换成Document文件
					3.通过实现接口BeanDefinitionDocumentReader的DefaultBeanDefinitionDocumentReader类对Document进行解析,并使用BeanDefinitionParserDelegate对Element进行解析

			容器的基础 XmlBeanFactory
				BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));
					1.使用ClassPathResource构造一个Resource资源对象实例,后续的资源处理就可以使用Resource对象


				配置文件封装
					Spring的配置文件读取是通过ClassPathResource进行封装的;
					在java中,将不同的资源抽象成URL,通过注册不同的handler(URLStreamHandler)来处理不同来源的资源的读取逻辑,一般的handler使用不同的前缀(协议,protocol)来识别,如"file:","http:","jar:"等,但是URL默认没有定义相对ClassPath或者ServletContext等资源的handler,虽然可以注册自己的URLStreamHandler来解析特定的URL前缀,比如"classpath:",但是这要了解URL的实现机制,而且URL也没有提供相应的方法,判断资源是否存在,资源是否可读等.因此Spring对其内部使用到的资源实现了自己的抽象结构:Resource接口封装底层资源

					Resource接口可以使用其getInputStream方法获取InputStream

					读源码读到有意思的东西
						1.HeapDumpWebEndpoint
						2.@WebEndpoint

				初始化
					1.构造函数需要一个Resource对象
					2.调用内部构造,传入parentBeanFactory为父类BeanFactory用于factory合并,可以为空
						1.调用父类构造方法
							在AbstractAutowireCapableBeanFactory的构造函数中,进行了初步初始化
							1.调用自身无参构造
							2.ignoreDependencyInterface
								ignoreDependencyInterface的主要功能是忽略给定接口的自动装配功能
									为什么要这么做?
									eg
										当A中有B属性,那么当Spring在获取A的实例的时候,如果B没有实例化,那么会自动初始化B,并注入到A中;
										但是,某些情况下,B不会初始化;其中一种情况就是B实现了BeanNameAware接口;Spring是这样介绍的,自动装配时忽略给定的依赖接口,典型应用是通过其它方式解析Application上下文注入依赖,类似BeanFactory通过BeanFactoryAware进行注入,或者ApplicationContext通过ApplicationContextAware注入
								1.忽略三种类型,BeanNameAware,BeanFactoryAware,BeanClassLoaderAware
						2.使用XmlBeanDefinitionReader读取资源文件
							1.loadBeanDefinitions 资源加载
							2.转化Resource为EncodeResource
							3.调用内部重载方法,loadBeanDefinitions
								1.将EncodeResource对象转成InputSource(为后续通过SAX读取XML的方式做准备)
								2.调用doLoadBeanDefinitions方法,进入核心处理逻辑
									1.loadDocument将InputSource和Resource转成Document对象
										1.调用doLoadDocument方法,验证xml
									2.registerBeanDefinitions根据Document对象注册Bean信息
										1.使用DefaultBeanDefinitionDocumentReader调用registerBeanDefinitions方法读取Document
											1.调用doRegisterBeanDefinitions方法,提取Document的root
												1.解析前的通用处理工作
													profile属性的使用
														简单来说就是可以配置开发和生产环境,达到两种环境隔离的效果
												2.调用preProcessXml,前置处理Xml文件
												3.调用parseBeanDefinitions 解析document对象
													1.判断是否默认命名空间,如果不是则使用用户自定义命名空间
													2.获取当前document所有的子节点
													3.如果是默认命名空间则调用parseDefaultElement方法使用spring默认的方式解析Node
														目前使用4种类型的标签,
															1.import
															2.alias
															3.bean
															4.beans
												4.postProcessXml后置处理Xml文件

				标签解析
					在spring默认的标签解析中有4中类型(import,alias,bean,beans)
						bean标签的解析以及注册
						DefaultBeanDefinitionDocumentReader.processBeanDefinition方法
							1.delegate.parseBeanDefinitionElement方法进行解析,返回BeanDefinitionHolder类型的bdHolder,bdHolder例如class,name,id,alias之类的属性
								1.重载方法调用parseBeanDefinitionElement(Element, BeanDefinition)
								2.获取当前Element的id和name
								3.当传入的BeanDefinition为空的时候构建一个BeanDefinition
								4.重载调用parseBeanDefinitionElement(Element,beanName, BeanDefinition)
									1.解析class属性
									2.解析parent属性
									3.使用class和parent创建承载属性的GenericBeanDefinition
									4.调用parseBeanDefinitionAttribute解析Element的各种属性并设置到BeanDefinition里面
									5.提取description
									6.调用parseMetaElement方法解析元数据
									7.调用parseLookupOverrideSubElements解析lookup-method属性
									8.调用parseReplacedMethodSubElements解析replaced-method属性
									9.调用parseConstructorArgElements解析构造函数属性
									10.调用parsePropertyElements解析property子属性
									11.调用parseQualifierElements解析qualifier子元素
								5.将获取到的信息封装到BeanDefinitionHolder里面
							2.当返回bdHolder不为空的情况,若存在默认标签的子节点下再有自定义属性,还需要再次对自定义标签进行解析
							3.解析完成后,需要对解析后的bdHolder进行注册,同样,注册操作委托给了BeanDefinitionReaderUtils的registerBeanDefinition方法
							4.最后发出响应时间,通知相关监听器,这个bean已经加载完成

				BeanDefinition
					BeanDefinition是一个接口,在Spring里有三种实现,都继承了AbstractBeanDefinition
						1.RootBeanDefinition
						2.ChildBeanDefinition
						3.GenericBeanDefinition

					lookup-method(也可以使用@Lookup注解)
						lookup-method通常称为获取器注入,简单来说,就是你定义一个获取bean的方法,这个方法由spring帮你注入bean

					replaced-method(spring暂时没有实现使用注解的方式进行替换,不过查看源码后可以得知,其实可以通过扩展处理器来进行修改BeanDefinition)

				BeanDefinitionParserDelegate
					decorateBeanDefinitionRequired方法
						此方法是通过命名空间进行匹配,进行bean定义的装饰

				BeanDefinitionReaderUtils
					registerBeanDefinition 注册beanDefinition的方法 此方法传入BeanDefinitionHolder和BeanDefinitionRegistry
						1.这里BeanDefinitionRegistry 接口的实现类是之前传入的DefaultListableBeanFactory
						2.调用DefaultListableBeanFactory进行BeanDefinition的注入,将beanName作为名称存入到beanDefinitionMap里面
						3.判断当前工厂是否已经开始初始化bean?只要有任何一个bean已经创建,那么就证明工厂已经开始创建bean了
						4.beanDefinitionMap存入beanDefinition, beanDefinitionNames存入beanName
						5.移除工厂内部手动注册的单例集合
						6.别名注册BeanDefinition
						7.getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));通知监听器解析以及注册完成
							这个方法的调用是为了扩展处理,Spring本身并没有进行任何逻辑处理
							ReaderEventListener 使用的listener是这个
								1.@EventListener作用在method上,发布自定义事件


	bean加载过程
		getBean获取spring上下文中bean实例
			1.提取beanName
				传入的参数beanName有可能是别名,也有可能是FactoryBean,需要一系列的解析
			2.getSingleton(beanName);
				1.检查缓存中或者实例工厂中是否有对应的实例
				2.为什么会有这段代码?因为spring在创建bean的时候会有依赖注入的情况,而在创建依赖的时候为了避免循环依赖spring创建bean的原则不等bean创建完成就会将bean的ObjectFactory提前曝光,也就是将ObjectFactory加入到缓存中,一旦下个bean创建的时候需要依赖上个bean则直接使用ObjectFactory直接尝试从缓存获取或者singleFactories中的ObjectFactory中获取
			3.getObjectForBeanInstance(sharedInstance, name, beanName, null);返回对应实例,有时候储存在BeanFactory的情况并不是返回实例本身而是返回指定方法返回的实例
			4.只有在单例的情况下才会尝试解决循环依赖的问题,原型模式情况下,如果存在A中有B的属性,B中有A的属性,那么当依赖注入的时候,就会产生当A还未创建完的时候因为对于B的创建再次返回创建A,造成循环依赖
				if (isPrototypeCurrentlyInCreation(beanName)) {
					throw new BeanCurrentlyInCreationException(beanName);
				}
			5.如果当前工厂已经加载的bean里面不存在当前beanName,那么尝试从父类工厂里面获取;递归从父类工厂里面获取bean
			6.如果不是做类型检查,则是创建bean,此时需要记录
				if (!typeCheckOnly) {
					markBeanAsCreated(beanName);
				}
			7.getMergedLocalBeanDefinition将存储的XML配置文件的GenericBeanDefinition转化称为rootBeanDefinition,如果指定beanName是子类的话,会同时合并到父类的相关属性
			8.如果存在依赖则要递归实例化依赖的bean, 这里的依赖是指的前置依赖;
			9.getSingleton()方法singleton模式的创建
			10.原型模式创建
			11.其它模式创建
			12.检查需要的类型是否符合bean的实际类型


		FactoryBean
			一般情况下,spring通过反射机制利用bean的class来实例化bean,在某些情况下,实例化bean的过程比较复杂;如果按照传统的方式,则需要在配置文件里面定义大量的信息,配置方式比较受限的,通过编码的方式就可以更加灵活的实例化bean;spring为此提供了一个FactoryBean的工厂类接口,用户可以实现该接口定制实例化bean的逻辑

				FactoryBean接口对于Spring框架来说占有很重要的地位,Spring自身就提供了70多个FactoryBean的实现,它们隐藏了实例化了一些复杂的bean的细节,给上层应用带来了便利;从spring3.0开始;FactoryBean开始支持泛型

		getSingleton(beanName)
			1.重载调用getSingleton(beanName, true);// true 是否允许早期依赖
			2.检查缓存中是否此单例对象
			3.如果为空,则锁定全局变量并行处理
			4.如果此bean正在加载则不处理
			5.当某些方法需要提前初始化的时候则会调用addSingletonFactory方法将对应ObjectFactory初始化策略存储在singletonFactories
			6.调用预先设定的getObject方法
			7.记录在缓存中,earlySingletonObjects和singletonFactories互斥

			
			singletonObjects 	用于保存BeanName和创建bean实例之间的关系, bean name -> bean instance
			singletonFactories 	用于保存beanName和创建bean工厂之间的关系,bean name -> ObjectFactory
			earlySingletonObjects 	也是保存beanName和bean实例之间的关系,与singletonObjects不同之处在于,当一个单例bean被放到这里之后,那么当bean还在创建过程中,就可以通过getBean方法获取到了,其目的是用来检测循环引用
			registeredSingletons 用于保存当前所有已注册的bean


		getObjectForBeanInstance
			getObjectForBeanInstance是一个高频使用方法,无论是从缓存中获取bean还是根据不同的scope策略加载bean;总之,在获取到bean的实例后要做的第一件事就是调用getObjectForBeanInstance来检测一下正确性,其实就是判断当前bean是否是FactoryBean类型的bean,如果是,那么需要调用该bean对应FactoryBean的getObject方法作为返回值

			1.如果指定的name是工厂相关(以&为前缀)且beanInstance又不是FactoryBean类型则验证不通过
			2.现在我们有一个bean有可能正常的bean也有可能是FactoryBean,如果是FactoryBean那么使用它创建实例,但是如果用户想要直接获取工厂实例而不是工厂的getObject方法返回的实例那么传入name应该加入前缀
			3.加载FactoryBean
				1.getCachedObjectForFactoryBean尝试从缓存中加载bean
				2.containsBeanDefinition检测beanDefinitionMap中也就是所有已经加载的类中检测是否定义beanName
				3.getMergedLocalBeanDefinition将存储XML文件的GernericBeanDefinition转化成RootBeanDefinition,如果bean是子类bean将会合并父类的属性
				4.是否用户定义的,而不是应用程序本身定义的
			4.调用getObjectFormFactoryBean返回bean实例
				1.如果是单例,那么需要保证其是全局唯一,同时使用缓存获取,提高性能
				2.调用doGetObjectFormFactoryBean获取bean实例
					1.判断是否需要权限验证
					2.直接调用FactoryBean的getObject方法
				3.创建完成检查,
				4.调用bean的后置处理器

		getSingleton(beanName, singletonFactory)
			1.全局变量需要同步
			2.检查bean是否已经加载过,singleton就是复用bean,只有为空的时候才能进行创建
			3.调用beforeSingletonCreation方法, 检查bean是否已经初始化
			4.调用之前匿名内部类构造的ObjectFactory调用getObject方法
			5.调用afterSingletonCreation方法检查,是否有重复创建bean
			6.加入单例bean集合,维护集合对象

		createBean(beanName, mdb, args)
			1.调用resolvedBeanClass方法获取bean的Class
				1.如果有class就直接返回class
				2.如果没有class,那么则用className去构造一个class对象
			2.对override属性进行标记与验证
				这里就是将lookup-method和replaced-method两个配置的操作进行处理
					spring在检测到有overrideMethods的时候,会动态为这个bean生成代理对象,并使用拦截器为bean做增强处理
					对于方法的匹配来说,如果一个类存在若干个重载方法,那么在函数调用的时候还需要根据参数类型进行匹配,来最终确认当前调用到底是哪个函数,但是,spring将一部分的工作在这里完成了,如果当前类中的方法只有一个,也就是没有重载;那么就设置该方法没有被重载,后续也就不用进行参数匹配,这样既进行了方法验证,又在后续操作中减少了性能开销,可真的是很吊了
			3.resolveBeforeInstantiation(beanName, mbdToUse)
				给BeanPostProcess一个机会返回bean
			4.调用doCreateBean方法创建bean

		resolvedBeforeInstantiation(beanName, mdbToUse)
			1.给BeanPostProcess一个机会调用返回bean,如果这里返回了bean;那么后面就不会进行创建
			2.调用bean的后置处理

		doCreateBean(beanName, mbdToUse, args)
			1.如果是单例bean,需要清除缓存
			2.createBeanInstance(beanName, mbd, args)实例化bean,将BeanDefinition转换成BeanWrapper
				1.如果存在工厂方法就使用工厂方法进行初始化
				2.一个类有多个构造函数,每个构造函数都有不同的参数,所以需要根据参数锁定构造函数并进行初始化
				3.如果不存在工厂方法也不存在待有参数的构造函数,则使用默认的构造函数进行bean的初始化
			3.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);MergedBeanDefinitionPostProcess的应用
				bean合并处理后,Autowired注解正是通过此方法实现诸如类型的预解析
			4.依赖处理
			5.populateBean(beanName, mbd, instanceWrapper);属性填充
			6.循环依赖检查
			7.注册DisposableBean
				如果配置了destroy-method,这里需要注册并在容器销毁时调用
		
		createBeanInstance(beanName, mbd, args)
			1.resolveBeanClass(mbd, beanName);获取当前bean的class
			2.如果存在Supplier,那么从Supplier获取实例
			3.instantiateUsingFactoryMethod(beanName, mbd, args);如果工厂不为空则使用工厂方法初始化策略
			4.当构造函数或者工厂方法的参数为null的时候,判断是否指定调用的构造函数或者工厂方法
				1.是否使用自动注入
				2.没有使用自动注入就使用默认构造

				这里使用了缓存,解析构造的过程是比较耗时的过程,如果已经解析过了,则不需要重复解析而是从BeanDefinition的属性ResolvedConstructorOrFactoryMethod缓存值中去取
			5.需要根据参数解析构造函数
			6.构造函数自动注入
			7.使用默认构造函数构造

			spring的实例化工程其实分成了两个部分
				1.一种是通用的实例化
				2.另一种是待有参数的实例化,带有参数的实例化过程非常复杂;因为存在着不确定性,所以在判断参数上做了大量工作

		autowireConstructor
			1.构造函数参数的确定
				如果传入的参数explicitArgs不为空,那么直接使用;因为explicitArgs参数是在调用bean的时候用户指定的,在BeanFactory类存在这样的方法
					Object getBean(String name, Object ... args)
				在获取bean的时候,用户不但可以指定bean的名称,还可以指定bean所对应的类的构造函数或者工厂方法的方法参数,主要是静态工厂方法的调用,而这里是需要给定完全匹配的参数,所以,便于判断;如果传入的explicitArgs不为空,则可以确认构造函数参数就是它
			2.从缓存中获取
				如果构造函数的参数存在缓存中,则直接从缓存中获取;缓存中存储的类型有可能是参数的最终类型也可能是参数的初始类型,比如构造器需要的最终类型是 Integer 1;但是缓存中的类型是String "1";那么即使在缓存中获取到了参数,也需要经过类型转化器的过滤以确保参数类型与对应的构造函数的参数类型能够完全对应上;这里的如果获取到了参数,也就是说之前已经创建过这个对象,那么会使用快速创建
			3.配置文件获取
				bean的配置信息都储存在BeanDefinition里面,可以调用mdb.getConstructorArgumentValues()方法获取配置的构造函数信息,如果是引用到另外一个bean,那么会通过resolveConstructorArguments方法,并返回能解析到参数的个数
			4.构造函数的确定
				1.构造函数排序
				2.获取参数名称
					1.根据注解获取参数名称
					2.使用工具类ParameterNameDiscoverer来获取
					3.根据确定的构造函数转换对应的参数类型
						主要使用Spring的类型转化器或者用户自定义的类型转化器进行转换
					4.构造函数的不确定性的验证

		instantiateBean(beanName, mbd);
			不带参数的构造
			调用实例化策略进行bean的实例化

		SimpleInstantiationStrategy与CglibSubclassingInstantiationStrategy
			实例化策略
			1.判断是否有overrideMethod,没有直接使用反射获取实例
			2.有overrideMethod必须使用cglib进行实例化,将两个方法特性的拦截器织入进去	

		doCreateBean
			// Eagerly cache singletons to be able to resolve circular references
			// even when triggered by lifecycle interfaces like BeanFactoryAware.
			boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
					isSingletonCurrentlyInCreation(beanName));
			if (earlySingletonExposure) {
				if (logger.isTraceEnabled()) {
					logger.trace("Eagerly caching bean '" + beanName +
							"' to allow for resolving potential circular references");
				}
				addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
			}

			这一段代码是spring解决循环依赖的逻辑

			earlySingletonExposure 提前曝光的单例
			mdb.isSingleton() bean的定义是否是单例
			this.allowCircularReferences 是否允许循环依赖,这设置只能通过硬编码的方式设置,或者可以使用自定义命名空间进行配置
				其中硬编码的方式如下
					ClassPathXmlApplicationContext bf = new ClassPathXmlApplicationContext("application.xml")
					bf.setAllowCircularReferences(false);
			isSingletonCurrentlyCreation(beanName)
				该bean是否在创建中,在Spring中,会有一个专门的属性DefaultSingletonBeanRegistry的singletonsCurrentlyInCreation来记录bean的加载状态,bean开始创建之前会将beanName记录在属性中,在bean创建结束后会将beanName从属性中移除;
				不同的scope记录位置并不一样,以singleton为例,在singleton下记录属性的函数是在DefaultSingletonBeanRegistry类的public Object getSingleton(String beanName, ObjectFactory singletonFactory)函数的beforeSingletonCreation(beanName)和afterSingletonCreation(beanName)中,在这两段函数中分别this.singletonsCurrentlyInCreation.add(beanName)和this.singletonCurrentlyInCreation.remove(beanName)来进行状态的记录与移除


		populateBean 填充属性
			1.InstantiationAwareBeanPostProcessor处理器的postProcessAfterInstantiation函数的应用,此函数可以控制程序是否继续属性填充
			2.根据注入类型(byName/byType),提取依赖的bean,并统一存入PropertyValues中;
			3.应用InstantiationAwareBeanPostProcessor处理器的postProcessPropertyValues方法,对属性获取完毕填充前对属性进行再次处理,典型的应用就是RequiredAnnotationBeanPostProcessor类中对属性的验证
			4.将所有PropertyValues中的属性填充到BeanWrapper中

		autowireByName
			1.unstisfiedNonSimpleProperties从BeanWrapper中寻找需要依赖注入的属性
			2.getBean递归初始化bean
			3.registerDependentBean注册依赖

		autowireByType
			1.ustisfiedNonSimpleProperties寻找beanWrapper中需要依赖注入的属性
			2.探测指定属性的set方法
			3.解析指定beanName的属性所匹配的值,并把解析到的属性名称存储在autowireBeanNames中,当属性存在多个封装bean时,如
				@Autowired
				private List<A> lists;
				将会匹配到所有A类型的实例,并注入到lists中
			4.registerDependentBean注册依赖

		DefaultListableBeanFactory的resolvedDependency函数
			这个函数的作用在于寻找匹配的类型
			1.new DependencyObjectFactory(descriptor, beanName)对于ObjectFactory类注入的处理
			2.new DependencyProviderFactory().createDependencyProvider(descriptor, beanName)javaxInjectProviderClass类注入的特殊处理
			3.doResolvedDependency通用处理逻辑

		doResolvedDependency函数
			1.用于支持Spring新增的@Value注解
			2.如果解析器没有解析成功,则需要考虑各种情况
				1.如果是数组类型
					1.根据属性类型找到beanFactory中所有类型的bean
					2.返回值构建称为: key=匹配的beanName, value=beanName对应实例化的bean(通过getBean(beanName)返回)
					3.如果autowired的require属性为true而找到的属性为空,则只能抛出异常
					4.通过类型转化器将bean的值转换为对应的type类型
				2.属性是Collection类型
				3.属性是Map类型

				寻找类型的匹配执行顺序,首先尝试使用解析器进行解析,如果解析器没有解析成功,那么可能使用默认的解析器没有做任何处理,或者使用了自己自定义的解析器,但是对于集合类型来说,并不在解析范围之内,所以再次对不同类型进行不同情况的处理,虽说对不同类型处理方式不一致,但是大致思路还是很相似的

		applyPropertyValues
			经过属性的解析设置之后,属性的获取都已经完成,但是获取的属性都是以PropertyValues的形式存在的,还没有实例化到bean中,这一工作是由applyPropertyValues完成
			1.如果PropertyValues是属于MutablePropertyValues类型,MutablePropertyValues类型的值已经被转换为对应的类型,那么就可以直接设置到beanWrapper中
			2.如果PropertyValues并不是MutablePropertyValues类型,那么直接使用原始的属性获取方法
			3.获取对应的解析器 BeanDefinitionValueResolver
				1.遍历属性,将属性转换为对应类的对应属性的类型

		initializeBean 初始化bean
			init-method会在这里调用,在此之前,Spring已经进行对bean的实例化,并且完成对属性填充,而就在此时会调用用户设定的初始化方法
			1.激活Aware方法
			2.调用applyBeanPostProcessorsBeforeInitialization方法
			3.调用invokeInitMethods方法,激活用户自定义的init方法
			4.调用applyBeanPostProcessorsAfterInitialization

			1.Aware类
				spring支持对Aware接口实现的相关类注入指定资源,

			2.BeanPostProcessor
				bean的后置处理器,Spring支持用户参与到Bean的创建以及初始化过程,在initializeBean方法里面,BeanPostProcessor的调用就在这里

			3.激活用户自定义的init方法
				invokeInitMethods方法除了调用init-method之外,还会激活实现了InitializingBean接口的实现类中的afterPropertySet方法

		注册DisposableBean
			Spring不止提供了初始化方法的扩展入口,也提供了销毁方法扩展入口,对于销毁方法的扩展,除了destroy-method方法外,还能通过DestructionAwareBeanPostProcessor来统一处理bean的销毁方法

	容器的功能与扩展
		ApplicationContext与BeanFactory是spring中装载bean的容器,绝大多数情况下,都是使用ApplicationContext,因为ApplicationContext有BeanFactory的所有功能

		启动Spring容器的方法在refresh方法里面
			refresh方法几乎包含了ApplicationContext中提供的所有功能

			1.prepareRefresh() 准备刷新的上下文环境
			2.obtainFreshBeanFactory 初始化BeanFactory,并进行XML读取
			3.prepareBeanFactory(beanFactory)进行BeanFactory进行功能填充
			4.postProcessBeanFactory 子类覆盖方法做额外的处理
			5.invokeBeanFactoryPostProcessors(beanFactory) 激活beanFactory各种处理器
			6.registerBeanPostProcessors(beanFactory) 注册拦截bean创建的bean处理器,这里只是注册,真正的调用是在getBean的时候
			7.initMessageSource 为上下文初始化Message源,即不同语言的消息体,国际化处理
			8.initApplicationEventMulticaster() 初始化应用消息广播器,并放入applicationEventMulticaster 中
			9.onRefresh() 留给子类来初始化其它的bean
			10.registerListeners() 在注册的bean中找到Listener bean, 注册到消息广播中
			11.finishBeanFactoryInitialization(beanFactory) 初始化非懒加载的单例bean
			12.finishRefresh() 完成上下文加载,发布应用初始化事件ContextRefreshEvent

		prepareRefresh
			环境验证
			1.initPropertySources 空方法,留给子类去实现
			2.getEnviroment().validateRequiredProperties(); 

		obtainFreshBeanFactory
			获取beanFactory,ApplicationContext是对beanFactory功能上的扩展,不但包含了BeanFactory的全部功能,更在其基础之上添加了大量的应用,obtainFreshBeanFactory正是实现BeanFactory的地方,也就是说经过这个函数之后,ApplicationContext就已经拥有了BeanFactory的全部功能
			1.调用refreshBeanFactory()方法,-->AbstractRefreshableApplicationContext
				1.调用createBeanFactory方法返回一个DefaultListableBeanFactory对象
				2.beanFactory.setSerializationId(getId())为了指定序列化id,如果需要的话,让这个beanFactory从id反序列化到BeanFactory对象
				3.customizeBeanFactory(beanFactory) 定制beanFactory,设置相关属性,包括是否允许覆盖同名称,是否允许循环依赖以及设置@Autowired和@Qualifier注解解析器,QualifierAnnotationAutowireCandidateResolver
					1.allowBeanDefinitionOverriding 是否允许重复
					2.allowCircularReference 是否允许循环依赖
					3.设置@Autowired和@Qualifier的注解解析器, 
						beanFactory.setAutowiredCandidateResolver(new QualifierAnnotationAutowireCandidateResolver())
				4.loadBeanDefinitions(beanFactory)初始化DocumentReader,并进行XML文件读取及解析
					1.构建XmlBeanDefinitionReader
					2.对BeanDefinitionReader进行环境变量设置
					3.initBeanDefinitionReader进行设置,可以覆盖
					4.调用loadBeanDefinitions(beanDefinitionReader)
						在初始化了DefaultListableBeanFactory和XmlBeanDefinitionReader后就可以进行对配置文件的读取了

		prepareBeanFactrory
			在调用这个方法之前,spring已经完成了对配置的解析,而ApplicationContext在功能上的扩展也由此展开
			1.beanFactory.setBeanClassLoader(getClassLoader()) 设置bean的类加载器
			2.beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver()) 设置表达式语言处理器,Spring3增加了表达式语言的支持
			3.beanFactory.setPropertyEditorRegister() 为beanFactory添加一个默认的propertyEditor,这个主要是对bean的属性等设置管理的一个工具
			4.beanFactory.setBeanPostProcessor(new ApplicationContextAwareProcessor(this)) 添加BeanPostProcessor
			5.设置几个忽略自动装配的接口
			6.设置几个自动装配的特殊规则
			7.增加对AspectJ的支持
			8.添加默认系统环境bean

			BeanFactory的后置处理
				BeanFactoryPostProcessor
				BeanFactoryPostProcessor接口和BeanpostProcessor类似,可以对bean的定义(配置元数据)进行处理,也就是说,SpringIoc容器允许BeanFactoryPostProcessor在容器实际实例化任何其它bean之前读取配置元数据,并有可能修改它,如果你愿意,你可以配置多个BeanFactoryPostProcessor;你还能通过设置order来指定BeanPostProcessor的执行顺序

				如果只是想改变bean的实例,最好使用beanPostProcessor,因为BeanFactoryPostProcessor作用域范围是容器级的;

				BeanFactoryPostProcessor的典型应用,PropertyPlaceholderConfigurer
					spring在加载bean之前会调用PropertyPlaceholderConfigurer的postProcessorBeanFactory方法
					这个方法会先后调用
						1.mergeProperties
						2.convertProperties
						3.processProperties

		invokeBeanFactoryPostProcessors
			1.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
				1.对beanDefinitionRegistry类型进行处理
					BeanDefinitionRegistryPostProcessor接口实现了BeanFactoryProcessor,但是有自己的独立方法,postProcessBeanDefinitionRegistry方法
					这个方法会首先调用
				2.如果不是BeanDefinitionRegistryPostProcessor类型的,就记录
				3.配置注册的后置处理器
					beanFactory.getBeanNamesForType() 方法找出BeanDefinitionRegistryPostProcessor类型的类,然后进行
				4.invokeBeanDefinitionRegistryPostProcessors 激活
					实现了PriorityOrdered这个接口
					说白了就是遍历调用BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法
				5.寻找到实现了Ordered接口的BeanDefinitionRegistryPostProcessor类
					然后进行注册调用
				6.循环调用所有BeanDefinitionRegistryPostProcessor类型的处理器,直到调用完为止
				7.调用所有BeanDefinitionRegistryPostProcessor的postProcessBeanFactory方法
				8.调用除BeanDefinitionRegistryPostProcessor的BeanFactoryPostProcessor的postProcessBeanFactory方法
				9.后面是一样的初始化BeanFactoryPostProcessor的postProcessBeanFactory方法
					这里会进行判断,如果这个BeanFactoryPostProcessor在之前已经初始化过了,那么就不会再进行初始化

		registryBeanPostProcessor
			这里是注册了BeanPostProcessor这个类,这个类的调用主要是在后面bean实例化的时候,才会进行调用的,这里只是进行了注册
			1.从beanFactory获取BeanPostProcessor类型的类
			2.获取之前的BeanPostProcessor数量, 加上1,再加上在上述从beanFactory中获取的BeanPostProcessor类的数组
				这块为什么要这么处理?
				1.首先是加多一个1,是因为后面进行了添加BeanPostProcessorChecker
			3.遍历获取到的BeanPostProcessor
				1.判断是否是PriorityOrdered类型	
					1.添加到priorityOrderedPostProcessors
					2.如果是MergedBeanDefinitionPostProcessor
						那么添加到InternalPostProcessor
				2.判断是否是ordered类型
					1.添加到OrderedPostProcess
				3.其它情况就是 没有排序要求的BeanPostProcessor
					1.添加到nonOrderedPostProcessorNames里面
				4.注册priorityOrdered类型的beanPostProcessor, 注册Ordered类型的beanPostProcessor,注册无排序要求的beanPostProcessor;
				5.注册MergedBeanDefinitionPostProcessor
					这里并非重复注册,在beanFactory中的addBeanProcessor方法中,会先移除掉BeanPostProcessor
				6.注册ApplicationListener探测器

		初始化消息资源
			1.国际化信息/本地化信息
				一般需要两个条件才能确定一个特定类型的本地化信息,它们分别是"语言类型", "国家/地区的类型";
				eg:
					1.带有语言, 国家/地区 信息的本地化对象
						Locale locale = new Locale("zh", "CN");
					2.只有语言的本地化对象
						Locale locale = new Locale("zh");
					3.等同于Locale locale = new Locale("zh", "CN");
						Locale locale = Locale.CHINA;
					4.等同于Locale locale = new Locale("zh");
						Locale locale = Locale.CHINESE;
					5.获取默认的本地化对象
						Locale locale = Locale.getDefault();

			2.JDK本地化工具类
				NumberFormat, DateFormat, MessageFormat

			3.Spring国际化
				Spring定义了一个国际化的接口MessageSource并且提供了几个易用的扩展类
				HierarchicalMessageSource和ApplicationContext接口扩展

				Spring注册单例信息
				beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);

		初始化ApplicationContextEventMulticaster
			initApplicationEventMulticaster()
			1.如果用户自定义了事件广播器,那么则使用用户自定义的事件广播器
			2.如果没有,则使用spring默认的ApplicationEventMulticaster
				并且使用spring的beanFactory将其注册为单例beanFactory.registerSingleton
			3.作为广播器，一定是用于存放监听器，并在合适的时候调用监听器
				SimpleApplicationEventMulticaster是spring默认的事件广播器
					1.multicastEvent 
						1.如果有可分辨类型，那么直接使用，如果没有可分辨类型，使用event分析出类型
						2.根据event和类型获取可执行的监听器；
						3.使用线程池调用监听器
		
		注册监听器registerListeners();
			1.使用硬编码注册
			2.使用配置文件注册

		初始化非延迟加载单例 finishBeanFactoryInitialization(beanFactory);
			1.ConveionService的一些设置
			2.冻结所有bean定义，此时bean不能再被修改
			3.初始化剩下的单例bean

			ConversionService的作用
				spring使用的两种转化器：
					1.Converter
					2.

			冻结配置freezeConfigurantion()
				1.冻结所有的bean定义，说明注册的bean将不能被修改或者进一步处理

			初始化非延迟加载
				1.ApplicationContext的默认行为是将所有的非延迟加载的bean在容器初始化的时候进行实例化
				2.初始化所有的单例bean之后，还会对触发bean的后置处理，需要实现SmartInitializingSingleton接口

		finishRefresh
			Spring还提供Lifestyle接口，Lifestyle包含了stop和start方法，实现此接口后Spring会保证在启动的时候调用start方法开始生命周期，并在spring关闭的时候吊桶stop方法结束生命周期

			1.清除资源文件的缓存
			2.初始化bean的生命周期类LifecycleProcessor，如果用户未自定义，则系统默认初始化一个DefaultLifecycleProcessor
			3.调用LifecycleProcessor的onRefresh方法
				1.获取所有的Lifecycle的接口的bean
				2.循环调用start方法启动
			4.publishEvent
				当完成ApplicationContext初始化的时候，要通过spring中的事件发布机制发出ContextRefreshEvent事件，以保证对应的监听器可以做进一步的逻辑处理

	AOP
		AOP示例：
			使用@Aspect注解，标注类
			然后标明切点，@Pointcut()
			标注是before，after，还是Around

		Spring在xml的情况下是通过<aop:aspectj-aotuproxy/>这个标签进行开始aop代理的
		这里是在AopNamespaceHandler对应着这样一段函数
			public void init() {
				...
				this.registerBeanDefinitionParser("aspectj-autoproxy", new AspectJAutoProxyBeanDefinitionParser());
			}
		这里的意思是，当遇到<aop:aspectj-aotuproxy/>的时候，就会使用解析器AspectJAutoProxyBeanDefinitionParser进行解析

		所有的解析器都是从BeanDefinitionParser接口的统一实现，入口函数都是parser
			AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);
				1.关于aop的实现都是通过AnnotationAwareAspectJAutoProxyCreator去实现的；这里就是注册AnnotationAwareAspectJAutoProxyCreator
				2.proxy-target-class与expose-proxy 属性设置
					1.使用哪种ap代理方式，spring支持通过proxy-target-class 属性设置aop代理的生成方式；
						1.JDK
						2.CGLIB
					2.内部调用的时候无法实现增强处理 expose-proxy
						eg：
							public class TestBean {
								public void a() {
									this.b();
								}
								publci void b() {

								}
							}
						这种情况无法对b进行切面， 设置<aop:aspectj-autoproxy expose-proxy= "true" />
						使用这种方式
							((TestBean)AopContext.currentProxy()).b();

		AnnotationAwareAspectJAutoProxyCreator
			这个实现了BeanPostProcessor接口
				postProcessAfterInitialization主要看这个方法
					1.根据给定的bean的class和name 构建出一个key， 格式: beanClassName_beanName
					2.如果需要代理wrapIfNecessary
						1.已经处理过
						2.不需要代理
						3.判断给定的类是否是一个基础设施类，如果是基础设施类则不需要代理，判断是否是要指定跳过的类，如果是指定要跳过的类，也不需要代理
						4.获取增强getAdvicesAndAdvisorsForBean
							1.findEligibleAdvisors 获取增强列表
								对于指定bean的增强方法获取一定是包含两个步骤的
									1.获取所有的增强方法findCandidateAdvisors
										1.获取所有的增强器buildAspectJAdvisors
											1.advisorFactory.getAdvisors(factory); 解析标记@AspectJ注解的类的增强方法
												1.获取标记为AspectJ的类
												2.获取标记为AspectJ的name
												3.验证
												4.getAdvisors获取增强器集合
													1.getAdvisor普通增强器的获取
														1.获取切点getPointcut
															1.获取方法上注解
																AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod); ASPECTJ_ANNOTATION_CLASSES 切面主要的类集合
															2.使用AspectJExpressionPointCut封装获取到的信息
														2.InstantiationModelAwarePointcutAdvisorImpl() 根据切点生成增强器
															1.instantiateAdvice 增强器的初始化
																1.aspectJAdvisorFactory.getAdvice 使用工厂生成增强器
																	1.根据注解的不同类型生成不同的增强器， 在增强器里面完成方法的增强
												5.当获取的advices集合不为空的时候，并且配置了延时加载；那么就生成一个
													SyntheticInstantiationAdvisor
													这个增强器是同步实例化增强器
													目的是初始化aspect
												6.DeclareParents增强器
													getDeclareParentsAdvisor方法
													1.判断是否有存在注解了@DeclareParents字段， 判断是否有defaultImpl
													2.通过构建DeclareParentsAdvisor对象，构建增强器
										几个常用的增强器
											1.MethodBeforeAdviceInterceptor 实现了MethodInterceptror接口
												1.类种含有MethodBeforeAdvice的引用
												2.上述生成的增强器，如AspectJMethodBeforeAdvice前置增强，就是MethodBeforeAdvice的子类
												3.MethodBeforeAdviceInterceptor通过调用其invoke方法，执行方法拦截

												before这种调用是通过MethodBeforeAdviceInterceptor持有MethodBeforeAdvice在调用真实的方法之前去调用MethodBeforeAdvice中的before方法，处理方式就是类似于前置的处理方式
											2.AspectJAfterAdvice
												1.实现了MethodInterceptor接口
												2.在invoke方法里面，直接执行方法，然后在finally里面调用after方法

									2.在所有增强方法中找到适用于bean的增强并应用findAdvisorsThatCanApply
										1.AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass); 得到过滤的增强器
											1.寻找引介增强器(针对字段的增强器)
											2.针对普通bean的增强
							2.如果List为Empty那么就返回null
						5.如果获取到了增强，则需要针对增强进行代理
							1.设置缓存里面
							2.createProxy创建代理对象
								1.AutoProxyUtils.exposeTargetClass 使用ConfigurableListableBeanFactory修改bean定义
								2.ProxyFactory创建代理工厂对象， 拷贝当前类对象 当前类是AnnotationAwareAspectJAutoProxyCreator，目的是获取当前类相关属性
								3.shouldProxyTargetClass(beanClass, beanName) 判断当前类的代理是否应该使用targetClass而不是接口代理
									1.evaluateProxyInterfaces 检查是否有接口，并且这些接口应该符合规范，即，不包含特殊接口； 必须包含所有的接口
								4.buildAdvisors(beanName, specificInterceptors);获取增强器， 设置增强器
									1.resolveInterceptorNames(); 解析注册的所有的interceptorName； 这里注册目前没有看到哪里可以注册，应该时候初始化的时候用户手动注册
									2.加入到拦截器
									3.advisorAdapterRegistry.wrap(allInterceptors.get(i)); 将拦截器进行封装转化成advice
								5.设置目标类
								6.子类扩展代理工厂
								7.设置冻结状态
								8.设置前置过滤，默认是false，子类可重写
								9.工厂获取代理对象 proxyFactory.getProxy(getProxyClassLoader());
									1.createAopProxy().getProxy(classLoader); 
									2.getAopProxyFactory().createAopProxy(this); 创建AopProxy对象； 这里使用了一个工厂模式
										属性介绍
										1.optimize用来控制CGLIB创建的代理是否使用激进化的优化策略，除非完全了解AOP代理如何进行优化，否则不推荐用户使用这个设置,这个设置对JDK代理(默认代理)无效
										2.proxyTargetClass这个属性设置成true；则目标类本身被代理，而不是目标类的接口，如果这个属性被设置成true将采用CGLIB动态代理
										3.hasNoUserSuppliedProxyInterfaces(config) 是否存在代理类的接口
							3.返回代理对象

			JDK与CGLIB方式总结：
				1.如果目标对象实现了接口，那么默认情况下会采用JDK动态代理实现AOP
				2.如果目标对象实现了接口，可以强制使用CGLIB实现AOP
				3.如果目标对象没有实现接口，必须采用CGLIB库，Spring会在JDK与CGLIB之间自动切换

			如何强制使用CGLIB实现AOP？
				1.添加CGLIB库， Spring_HOME/cglib/*.jar
				2.<aop:aspectj-autoproxy expose-proxy= "true" />

			JDK动态代理与CGLIB字节码生成的代理有什么区别？
				1.JDK动态代理只能针对实现了接口的类生成代理，而不能针对类
				2.CGLIB是针对类实现代理，主要是针对目标类生成一个子类；覆盖其中的方法，因为是继承，所以类与方法最好不要声明为final


			JdkDynamicAopProxy
				1.getProxy 获取代理对象
					1.获取实现的接口数组
					2.过滤equals和hashCode方法
					3.Proxy.newProxyInstance(classLoader, proxiedInterfaces, this); 创建代理

				2.invoke方法
					1.equals方法处理
					2.hashCode方法处理
					3.Class类的isAssignableFrom(Class cls) 方法如果调用这个方法class与接口参数cls表示的类或者接口相同，或者cls表示的类或者接口的父类，则返回true
					4.oldProxy = AopContext.setCurrentProxy(proxy); 目标的内部调用无法实现增强，则可以使用此属性暴露代理
					5.List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); 获取此方法的拦截链
					6.没有拦截链就直接调用
					7.如果有拦截链，封装成一个ReflectiveMethodInvocation，以便调用使用拦截器； retVal = invocation.proceed(); 调用
						1.执行完所有增强后执行切点方法
						2.获取下一个要执行的拦截器
						3.动态匹配
						4.不匹配则不执行
						5.普通拦截器，将this作为参数，以确保在当前实例中调用链的执行

					8.返回结果

			CGLIB动态代理，暂时不管了



	JDBC
		springJdbc 这个可以不看，之前看过源码


		mybatis 看过部分源码，重新整理
		2020-11-26 11:07 继续看源码

		mybatis配置文件基本结构
			1.configuration 根元素
			2.properties 定义配置外在化
			3.settings 一些全局配置
			4.typeAliases 类型别名
			5.typeHandler 定义类型处理， 也就是java类型与数据库中类型的转化
			6.objectFactory 用于指定结果集对象的实例是如何创建的
			7.plugins mybatis插件， 插件可修改mybatis内部的运行逻辑
			8.environments mybatis运行环境
			9.transactionManager 事务管理器
			10.dataSource 数据源
			11.mappers 指定映射文件或者映射类

		spring整合mybatis 
			通过对配置文件的读取，是通过SqlSessionFactoryBean封装了对mybatis的实现

			SqlSessionFactoryBean 实现了FactoryBean 与 InitializingBean 
				1.InitializingBean 实现了这个接口会在初始化的调用其afterPropertySet方法
				2.FactoryBean 一旦某个bean实现该接口，那么通过getBean方法获取的bean时，其实是获取此类的getObject() 返回的实例

				1.afterPropertySet 
					1.校验基本属性
					2.buildSqlSessionFactory() 构建SqlSessionFactory

				2.getObject 返回SqlSessionFactory实例

			MapperFactoryBean的创建
				为了使用mybatis的功能，spring配置文件提供两个bean
					1.SqlSessionFactoryBean 此bean是为了配置mybatis
					2.MapperFactoryBean 此bean注册mapper，访问数据库

				MapperFactoryBean同样实现了FactoryBean与InitializingBean接口
					1.afterPropertySet 初始化
						1.checkDaoConfig 检查配置
							1.检查sqlSessionTamplate 是否存在
							2.检查mapperInterface 是否存在
							3.addToConfig 是否能添加Mapper接口，并且接口没有注册过
						2.initDao(); 初始化Dao， 模板方法，留给子类扩展

					2.getObject 返回SqlSession的Mapper代理类


				SqlSessionTempalte 实现了SqlSession接口， SqlSession作为根据接口创建映射器代理的接触类一定不可以空，而SqlSession的初始化工作是在设定其设定其SqlSessionFactory属性的时候完成的

					1.setSqlSessionFactory 设置SqlSessionFactory， 如果SqlSessionTemplate为空，或者不等SqlSessionTemplate的SqlSessionFactroy就重新创建一个SqlSessionTemplate
						1.createSqlSessionTemplate 创建SqlSessionTemplate

				在mybatis中并没有调用configuration.addMapper方法，而是在映射文件读取过程中一旦解析到<mapper namespace="Mapper.UserMapper">，便会自动进行类型映射，而在spring中，单独拿出这个功能来验证；如果你保证这个接口一定存在映射文件，那么这个验证没有存在的必要，但是这里是我们自行决定的配置，无法保证这里配置的接口一定存在映射文件

					这里的自行配置是指的在配置SqlSessionFactory的时候，我们可以自动配置，而不用依赖于Xml



				Configuration.addMapper 这里是mybatis将Mapper文件和接口映射起来主要步骤
					这里的代码是mybaitis的逻辑
					1.mapperRegistry.addMapper(type);
						MapperRegistry 是mybatis注册Mapper接口的类
							1.判断是否是接口
							2.是否已经注册过这个mapper接口
							3.将mapper接口作为key，MapperProxyFactory作为value 存放到knownMappers； 此mapper是存放接口代理类的map对象
								1.MapperProxyFactory 存放着接口的class对象
									1.MapperProxy 实现了InvocationHandler， 在JDK动态代理的时候，调用其invoke方法

						MapperAnnotationBuilder mapper的注解解析建造者
							1.传入mapper接口与configuration
							2.parser.parse();解析
								1.验证是否已经加载资源文件
									1.loadXmlResource(); 加载xml资源文件
									2.加载资源文件
									3.设置当前命名空间名称
									4.解析缓存
									5.解析CacheNamespaceRef 命名空间缓存， 此处应该是mybatis的二级缓存
									6.获取mapper接口的所有方法
									7.判断，如果不是桥方法(bridge method， 此处在之前spring的解析中提到过) 就解析method生成statement
									8.parseStatement(method); 解析生成statement并且添加到configuration里面
										1.getParameterType获取方法的参数类型， 如果有超过一个，那么就指定是map类型
										2.获取数据库方言，使用@Lang 注解
										3.从方法注解上获取sql资源对象
											1.判断method上是否有@Select，@Update， @Delete，@Insert 注解
											2.判断method上是否有@SelectProvider 等注解
											3.buildSqlSourceFromStrings(strings, parameterType, languageDriver);获取@Select 等注解的value，生成资源文件
												1.拼接sql 
												2.languageDriver.createSqlSource(configuration, sql.toString().trim(), parameterTypeClass); 生成资源文件
													1.如果是<script>开头，那么就是xml的解析
													2.否则就构建一个GenericTokenParser 解析对象去解析SQL语句
											4.new ProviderSqlSource(assistant.getConfiguration(), sqlProviderAnnotation, type, method);创建一个资源对象SqlResource
										4.assistant.addMappedStatement添加mapperStatement； MapperBuilderAssistant 
											1.判断id是否在此命名空间已经存在？
											2.MappedStatement.Builder 初始化建造者
											3.statementParameterMap构建parameter的对象
											4.如果有参数，那么就将参数设置到建造者中
											5.调用build方法校验
											6.添加到configuration的mapperStateMent里面

											题外话，MD，真的瞎；连静态内部类的实例化都没有看到，这里成员变量的实例化，其实是需要静态内部类的实例化，其实和外部类没有毛的区别


				这里终于看到了mybtais使用Proxy类，使用的是JDK的动态代理；果然，一段代码看个几十遍还是有用的

			MapperScannerConfigurer
				MapperScannerConfiggurer 是Spring通过扫描特定包的，自动生成映射器的类 
				实现接口
					1.BeanDefinitionRegistryPostProcessor
						1.postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) BeanDefinition的注册信息
						2.postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) 这个方法来自BeanFactoryPostProcessor 这个类可以修改Spring的上下文对象， 此时所有的beanDefinitions也就是bean定义已经加载，但是bean还没有实例化，这里允许覆盖或者添加一些属性在bean初始化的时候使用
					2.ApplicationContextAware
						setApplicationContext(ApplicationContext applicationContext) 设置上下文对象
					3.InitializingBean
						afterPropertySet 初始化设置属性

				postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) MapperScannerConfigurer
					1.processPropertyPlaceHolders 
						processPropertyPlaceHolders()
							1.BeanDefinitionRegistries 在启动的时候应用，其优先级早于BeanFactoryPostProcessors；这意味PropertyResourceConfigurers加载不了属性，类对属性的引用会失效；因此，需要手动的找到定义的PropertyResourceConfigurers并且提前调用，以保证对属性的引用可以正常工作
							2.获取PropertyResourceConfigurer属性加载控制器
							3.获取当前对象MapperScannerConfigurer的bean定义；
							4.构建一个DefaultListableBeanFactory，将当前类MapperScannerConfigurer的BeanDefinition设置进去
							5.让获取到的PropertyResourceConfigGurers重新为Bean定义设置值
							6.刷新basePackage， sqlSessionFactoryBeanName， sqlSessionTemplateBeanName的值
					2.构建ClassPathMapperScanner对象并设置属性值
						1.这里有很多属性，但对结果影响的并不多；所以Spring在这里会给特殊属性设置一个过滤器registerFilters()
							1.annocationClass属性处理，如果不为空，那么只接受标注了该注解的的接口
							2.markerInterface 只接受实现了该接口的接口
							3.acceptAllInterface 如果annotationClass和markerInterface任一属性有值，acceptAllinterface就会改变，否则就会设置一个TypeFilter接口的局部类，旨在接受所有接口文件
							4.package-info.java处理， 对于命名为package-info的java文件，默认不作为逻辑接口实现，将其排除掉，使用TypeFilter接口的局部类实现match方法

						2.设置了相关属性，以及对应过滤器，便可以开始扫描文件了，对应的逻辑是在scan方法里面
							1.统计需要扫描文件的数量
							2.扫描的动作交给了doScan方法去做
								1.调用父类的doScan方法
									1.findCandidateComponents(String basePackage)扫描basePackage下的java文件
										1.isCandidateComponent(metadataReader) 判断当前文件是否符合要求
											1.是否是排除的资源
											2.资源是否符合要求
										2.将资源包装成ScannedGenericBeanDefinition
									2.解析scope属性
									3.判断是否AnnotatedBeanDefinition, 如果是需要检测一下常用的类型,如Lazy, Primary等
									4.检查bean是否有注册
									5.如果bean是用于代理生成的代理bean,需要进一步处理
								2.processBeanDefinitions(Set<BeanDefinitionHolder> beanDefinitions) 对bean进行处理
							3.includeAnnotationConfig属性的处理,AnnotationConfigUtils.registerAnnotationConfigProcessor主要是完成注解处理器的简单处理 如,AutoWiredAnnotationBeanProcessor, RequiredAnnotationBeanProcessor


    事务
    	开启事务的标签是<tx: annotation-driven transaction-manager="transactionManager"/>
    	需要指定一个事务管理器

    	spring是在xml解析该标签指定事务管理器

    	解析的动作在TxNamespaceHandler的init方法里面
    	@Override
		public void init() {
			registerBeanDefinitionParser("advice", new TxAdviceBeanDefinitionParser());
			registerBeanDefinitionParser("annotation-driven", new AnnotationDrivenBeanDefinitionParser());
			registerBeanDefinitionParser("jta-transaction-manager", new JtaTransactionManagerBeanDefinitionParser());
		}

		spring在解析标签的时候会通过AnnotationDrivenBeanDefinitionParser类的parse方法进行解析

		AnnotationDrivenBeanDefinitionParser
			1.parse
				首先会解析是否存在model属性，model属性指定事务切入的方式，可以指定为AspectJ方式，也可以指定为proxy(默认)
			2.AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);
				AopNamespaceUtils.registerAutoProxyCreatorIfNecessary(parserContext, element);
					BeanDefinition beanDefinition = AopConfigUtils.registerAutoProxyCreatorIfNecessary(
						parserContext.getRegistry(), parserContext.extractSource(sourceElement));
					以上两个方法的目的都是为了注册InfrastructureAdvisorAutoProxyCreator


				默认的方式
				1.创建TransactionAttributeSource的bean
				2.parserContext.getReaderContext().registerWithGeneratedName(sourceDef);并使用spring的定义的规则生成beanName
				3.创建TransactionInterceptor的bean
				4.registerTransactionManager(element, interceptorDef);注册事务管理者
				5.创建BeanFactoryTransactionAttributeSourceAdvior的bean
				6.如果配置了order属性，那么就加入到bean中
				7.创建compositeComponentDefinition
				8.添加以上创建的3个bean，parserContext.registerComponent(compositeDef);注册compositeComponentDefinition


				以上注册的三个bean
					1.TransactionAttributeSource
					2.TransactionInterceptor
					3.BeanFactoryTransactionAttributeDefinition
				支撑了spring的事务功能
					其中TransactionAttributeSource与TransactionInterceptor被注册到了BeanFactoryTransactionAttributeDefinition里面

		InfrastructureAdvisorAutoProxyCreator 
			类结构分析
				1.实现了SmartInstantiationAwareBeanProcessor
				2.实现了BeanFactory接口

			2020-11-30 继续看代码感觉身体被掏空，想想之前也是傻；总觉得时间很多；一心想写代码，觉得读源码是一件很无聊的事情；不愿意下苦功夫读源码，不过后来想想，读源码确实没有自己写出好看代码那种满足感来的强烈；不过，读的源码越多，越来越觉得，自己应该可以做的更加好一些；自己可以尝试一些不同的东西；另外，spring牛逼！！！

			也就是说，spring在实例化InfrastructureAdvisorAutoproxyCreator的时候，会保证调用其postAfterInitialization方法
				postProcessAfterInitialization
					1.添加缓存， 根据bean和class构建出个key==> beanClassName_beanName
					2.wrapIfNecessary是否是由于避免循环依赖而创建的bean代理
						1.判断是否已经处理过这个bean
						2.判断此bean是否是基础bean，是否是指定跳过的bean
						3.getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);获取bean的增强器
							1.findEligibleAdvisors(beanClass, beanName); 获取当前bean的增强器
								1.findCandidateAdvisors();获取所有的增强器
									1.从BeanFactoryAdvisorRetireValHelper.findAdvisorBeans() 找到当前beanFactory中或有符合要求的Advisor Bean忽略FactoryBeans和正在创建的bean
										1.使用beanFactory获取Advisor的beanNames
										2.使用beanFactory获取Advisor的bean
								2.findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName); 获取当前bean的增强器
									1.AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass); 寻找当前类的增强器
										1.canApply(candidate, clazz, hasIntroductions) 匹配
											1.canApply(pca.getPointcut(), targetClass, hasIntroductions); 通过切点匹配
												1.methodMatcher.matches(method, targetClass) 匹配逻辑，这里进入TransactionAttributeSourcePointcut
													1.tas.getTransactionAttribute(method, targetClass) TransactionAttributeSource这里指的是AnnotationTransactionAttributeSource
														1.TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass); 获取事务注解标签
															1.txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());尝试在当前类里面寻找事务注解
																1.determineTransactionAttribute(clazz); 寻找事务注解
																	1.annotationParser.parseTransactionAnnotation(element); 调用parser解析注解Element，这里的parser是SpringTransactionAnnotationParser
						4.添加到缓存，创建代理返回

				创建事务增强器的逻辑:
					1.找出某个增强器是否适合于对应的类，而是否匹配的关键在于是否从指定的类或者类的方法中找到对应的事务属性
					2.当判断某个bean适用于事务增强时，也就是适用于增强器BeanFactoryTransactionAttributeSourceAdvisor，在解析自定义标签的时候，注入的类成为了整个事务功能的基础
					3.BeanFactoryTransactionAttributeSourceAdvisor是Advisor的实现类，自然要遵从Advisor的处理方式，当代理bean被调用的时候，会调用这个类的增强方法，也就是此bean的Advise,又因为在解析事务定义标签的时候，我们将TransactionInterceptor类型的bean注入到了BeanFactoryTransactionAttributeSourceAdvisor中，所以在调用事务增强器增强的代理类时会首先执行TransactionInterceptor进行增强，同时，也就是在TransactionInterceptor类中的invoke方法中完成整个事务的逻辑

		TransactionInterceptor
			事务拦截器，此类实现了MethodInterceptor,所以分析此类要从invoke方法开始
			invoke(MethodInvocation invocation)
				1.获取targetClass
				2.invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);
					1.获取事务属性
					2.determineTransactionManager(txAttr);获取事务管理器
					3.methodIdentification(method, targetClass, txAttr); 获取构造方法唯一标识
					4.声明式事务处理
						1.createTransactionIfNecessary(tm, txAttr, joinpointIdentification); 创建TransactionInfo
						2.invocation.proceedWithInvocation(); 执行被增强的方法
						3.completeTransactionAfterThrowing(txInfo, ex); 回滚
						4.cleanupTransactionInfo(txInfo); 清除消息
						5.commitTransactionAfterReturning(txInfo); 提交事务
					5.编程式事务处理
						使用了CallBackPerferringPlatformTransactionManager的execute方法
						1.prepareTransactionInfo(tm, txAttr, joinpointIdentification, status); 创建TransactionInfo
						2.invocation.proceedWithInvocation(); 执行被增强的方法
						3.txAttr.rollbackOn(ex) 回滚
						4.cleanupTransactionInfo(txInfo); 清除消息

			声明事务处理的主要步骤：
				1.获取事务属性
					对于事务来说，最基础或者最首要的功能便是获取事务属性，这是支撑整个事务功能的基石，如果没有事务属性，其它功能也就无从谈起；在分析事务准备阶段时我们已经分析了事务属性的提取功能
				2.加载配置种的配置TransactionManager
				3.不同的事务处理方式使用不同的逻辑
					对于声明式事务和编程式事务的处理，第一点区别在于事务属性上，因为编程式事务的事务处理是不需要事务属性的，第二点区别就是在TransactionManager上，CallBackPerferringPlatformTransactionManager实现了PlatformTransactionManager接口，暴露出一个方法用于执行事务处理的回调，所以，这两种方式都可以用作事务处理方式的判断
				4.在目标方法执行前获取事务并收集事务信息
					事务信息与事务属性并不相同，也就是TransactionInfo和TransactionAttribute不相同，TransactionInfo包含了TransactionAttribute的信息，但是除了TransactionAttribute的信息除外，还有其它事务信息，例如：PlatformTransactionManager和TransactionStatus的相关信息
				5.执行目标方法
				6.一旦出现异常，尝试异常处理
					并不是所有异常，spring都会将其回滚，默认只会对RuntimeException进行处理
				7.提交事务前的事务信息清除
				8.提交事务


				1.createTransactionIfNecessary(tm, txAttr, joinpointIdentification); 创建事务
					1.如果没有名称指定则使用方法唯一标识，并使用DelegatingTransactionAttribute封装txAttr
					2.tm.getTransaction(txAttr); 获取transactionStatus
					3.prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);根据指定的属性和status准备一个TransactionInfo

					对于createTransactionIfNecessary函数主要做了这样几件事情
						1.使用DelegatingTransactionAttribute封装传入的TransactionAttribute实例，对于传入的TransactionAttribute参数txAttr，当前实例是RuleBasedTransactionAttribute，是由获取事务属性时生成，主要用于数据承载，而这里之所以使用DelegatingTransactionAttribute进行封装，当然时提供了更多的功能
						2.获取事务
							事务处理当然以事务为核心，那么获取事务就是最重要的事情
						3.构建事务信息
							根据之前几个步骤获取的信息构建TransactionInfo返回
				2.tm.getTransaction(txAttr); 获取事务
					1.doGetTransaction()
						这里使用的DataSourceTransactionManager创建事务的实例
						1.创建DataSourceTransactionObject
						2.TransactionSynchronizationManager.getResource(obtainDataSource());如果当前线程已经记录数据库连接则使用原有连接
						3.txObject.setConnectionHolder(conHolder, false); false表示非新建连接
					2.isExistingTransaction(transaction)判断当前线程里面是否存在事务，判断依据是为当前线程记录的连接数不为空且连接中
					3.handleExistingTransaction(definition, transaction, debugEnabled); 处理当前线程已经存在事务的情况
					4.事务超时验证
					5.如果当前线程不存在事务，但是definition.getPropagationBehavior()被声明为TransactionDefinition.PROPAGATION_MANDATORY抛出异常
					6.suspend(null); 空挂起
					7.newTransactionStatus(
						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);构建TransactionStatus
					8.doBegin(transaction, definition); 构建transaction，包括ConnectionHolder，隔离级别，timout，如果是新链接，绑定到当前线程
					9.prepareSynchronization(status, definition); 新同步事务的设置，针对于当前线程的设置

					1.获取事务
					2.如果当前线程存在事务，则转向嵌套事务的处理
					3.事务超时设置验证
					4.事务属性propagationBehavior属性的设置验证
					5.构建DefaultTransactionStatus
					6.完善transaction，包括设置ConnectionHolder，隔离级别，timeout，如果是新连接，则绑定到当前线程
						对于一些隔离级别，timeout等功能的设置并不是由spring来完成的，而是委托给底层的数据库连接去做的，而对于数据库连接的设置在doBegin函数中处理

				3.doBegin(transaction, definition); 开始事务
					1.构造DataSourceTransactionObject，设置connectHolder，timeout，隔离级别； 如果是新事务，则绑定到当前线程
					2.DataSourceUtils.prepareConnectionForTransaction(con, definition); 获取数据库隔离级别
					3.更改自动提交，txObject.setMustRestoreAutoCommit(true);con.setAutoCommit(false);
					4.prepareTransactionalConnection(con, definition); 如果是只读，设置只读事务
					5.txObject.getConnectionHolder().setTransactionActive(true); 设置当前线程是否存在事务的依据
					6.TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder()); 获取到的连接绑定到当前线程

					从这个函数开始，已经开始尝试对数据库的获取，当然，对于数据库的获取；一些必要的设置也是需要同步设置的
					1.尝试获取连接，
						当然不是每次都会获取新的连接，如果当前线程中的connectionHolder已经存在，则没有必要重新获取，或者，对于事务同步标识设置成true的则需要重新获取连接
					2.设置隔离级别与只读标识
					3.更改默认的提交设置
						如果事务时自动提交，那么需要改变这种设置；将提交事务的权力转移到spring手上进行处理
						con.setAutoCommit(false); jdbc开启事务
					4.设置标识位，标识当前线程的事务已经激活
					5.设置过期时间
					6.将connectionHolder绑定到当前线程

				4.prepareSynchronization(status, definition); 将事务信息记录到当前线程中

				5.handleExistingTransaction(definition, transaction, debugEnabled); 处理已经存在的事务
					PROPAGATION_REQUIRED–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 
					PROPAGATION_SUPPORTS–支持当前事务，如果当前没有事务，就以非事务方式执行。 
					PROPAGATION_MANDATORY–支持当前事务，如果当前没有事务，就抛出异常。 
					PROPAGATION_REQUIRES_NEW–新建事务，如果当前存在事务，把当前事务挂起。 
					PROPAGATION_NOT_SUPPORTED–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 
					PROPAGATION_NEVER–以非事务方式执行，如果当前存在事务，则抛出异常
					PROPAGATION_NESTED-嵌套事务

					1.SuspendedResourcesHolder suspendedResources = suspend(transaction); 新事务的建立
					2.useSavepointForNestedTransaction() 设置保存点
					3.如果不能设置保存点，则新建事务

					事务的处理过程中，对于已经存在的事务处理考虑两种情况
						1.PROPAGATION_REQUIRES_NEW
							表示当前事务必须在自己的事务里运行，如果有一个事务正在运行，则在这个方法期间被挂起，而spring中对于此种传播方式的处理与新事务建立最大的不同点在于使用suspend方法将原事务挂起；将此信息挂起的目的是为了在当前事务执行完毕之后将原来的事务还原
						2.PROPAGATION_NESTED
							表示当前如果有一个事务正在运行中，则该方法应该运行在一个嵌套的事务中，被嵌套的事务可以独立的封装事务进行提交或者回滚；如果封装事务不存在，行为就像PROPAGATION_REQUIRES_NEW，对于嵌套式事务处理，spring主要考虑了两种方式；
								1.spring允许嵌套事务的时候，首选设置保存点的方式作为异常处理的回滚
								2.对于其它方式，spring，比如JTA无法使用保存点，那么处理的方式和PROPAGATION_REQUIRES_NEW相同，一旦出现异常；则由spring的事务异常处理机制去完成后续操作

						嵌套事务与新事务有什么不同？
							使用嵌套事务前提条件
								1.设置transactionManager的nestedTransactionAllowed为true，默认是false
								2.java.sql.Savepoint必须在jdk1.4+
								3.Connection.getMetaData().supportsSavepoints()必须为true ,即jdbc drive必须支持JDBC3.0

						PROPAGATION_REQUIRES_NEW
							如果当前执行环境存在事务，挂起当前事务，重新建立打开新事务，当前事务和新建事务直接相互不产生影响，比如正在工作来了个普通推销电话，放下手头的事情接过电话（挂起当前事务），继续完成未完成的工作（恢复当前事务）

						PROPAGATION_NESTED 
							它是已经存在事务的一个真正的子事务. 潜套事务开始执行时,  它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交或回滚.
							也就是外部事务提交子事务才能commit，外部事务回滚子事务也回滚
							如果内部事务回滚将不影响外部事务，内部事务回滚时只回滚到savepoint，当然内部事务可以通过回滚手动抛出异常影响外部事务（业务需求而定），当然有很多种组合

				6.suspend(transaction); 挂起事务
					1.检查事务是否是活跃状态
					2.获取当前线程挂起的事务，
					3.doSuspend(transaction);将当前事务挂起
					4.返回挂起的资源SuspendedResourcesHolder


				7.prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);准备事务连接信息
					当已经建立了事务连接并完成了事务消息的提取后，我们需要将所有的事务信息统一的记录在TransactionInfo类型的实例中，这个实例包含了目标方法开始前的所有状态信息，一旦事务执行失败，Spring会通过TransactionInfo类型的实例来进行回滚等后续工作
					1.创建TransactionInfo实例，根据 tm(事务管理器),txAttr(事务属性), joinpointIdentification(连接点信息)
					2.设置事务状态
					3.txInfo.bindToThread();绑定到当前线程

				8.completeTransactionAfterThrowing(txInfo, ex);回滚处理
					1.抛出异常的时候，先判断当前线程是否存在事务，这是基础依据
					2.判断异常类型是否是RunTimeException或者是Error；这里如果有指定回滚异常，会根据异常类型进行匹配
					3.txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());回滚事务
						1.status.isCompleted()如果事务已经完成，就抛出异常
						2.processRollback(defStatus, false);处理事务回滚
							1.triggerBeforeCompletion(status); 激活所有TransactionSynchronization中对应的方法
							2.status.rollbackToHeldSavepoint();如果有保存点，也就是当前事务为单独的线程退回到保存点
							3.如果是新事务，执行回滚逻辑；doRollback(status);
							4.如果当前事务不是独立的事务，那么只能标记状态，等到事务链执行完毕后统一回滚；doSetRollbackOnly(status);
							5.激活所有TransactionSynchronization中的方法；triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);
							6.清空记录的资源并将挂起的资源恢复；cleanupAfterCompletion(status);

								同样，spring中复杂逻辑的处理过程，入口函数一般都会给出个整体的处理脉络，而把实现的细节委托给其它函数去执行，大致脉络如下
									1.首先是自定义触发器的调用，包括在回滚前，完成回滚后的调用，当然完成回滚包括正常回滚与回滚过程中出现异常，自定义触发器会根据这些信息进行进一步处理，而对于触发器的注册，常见的实在回调过程中通过TransactionSynchronizationManager类中的静态方法直接注册
										registerSynchronization(TransactionSynchronization synchronization)
									2.除了触发监听函数外，就是真正的回滚逻辑处理了
										1.当之前已经保存的事务信息中有了保存点信息的时候，使用保存点进行回滚。常用于嵌入式事务，对于嵌入式事务处理，内嵌的事务异常并不会引起外部事务的回滚

										根据保存点回滚的实现，其实是根据底层的数据库连接进行的；
											public void rollbackToHeldSavepoint() throws TransactionException {
												Object savepoint = getSavepoint();
												if (savepoint == null) {
													throw new TransactionUsageException(
															"Cannot roll back to savepoint - no savepoint associated with current transaction");
												}
												getSavepointManager().rollbackToSavepoint(savepoint);
												getSavepointManager().releaseSavepoint(savepoint);
												setSavepoint(null);
											}
										这里使用的JDBC的方式进行数据库连接，那么getSavepointManager()函数返回的是JdbcTransactionObjectSupport，也就是说，上面的函数会调用JdbcTransactionObjectSupport的rollbackToSavepoint(savepoint);方法
										
										2.当之前已经保存的事务信息中的事务是新事务，那么直接回滚，常用于单独事务的处理，对于没有保存点的回滚，Spring同样是使用底层数据库连接提供的API来操作的，由于我们使用的是DataSourceTransactionManager,那么doRollback函数会使用此类的实现
												@Override
												protected void doRollback(DefaultTransactionStatus status) {
													DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();
													Connection con = txObject.getConnectionHolder().getConnection();
													if (status.isDebug()) {
														logger.debug("Rolling back JDBC transaction on Connection [" + con + "]");
													}
													try {
														con.rollback();
													}
													catch (SQLException ex) {
														throw new TransactionSystemException("Could not roll back JDBC transaction", ex);
													}
												}

										3.当前事务信息中是存在事务的，又不属于以上两种情况，多数用于JTA，只做回滚标识，等到提交的时候统一不提交

									3.cleanupAfterCompletion(status);回滚后信息的清除
										对于回滚逻辑执行结束后，无论回滚是否成功，都必须要做的事情就是事务结束后的收尾工作
										1.status.setCompleted();设置线程状态完成标识
										2.TransactionSynchronizationManager.clear();如果当前事务是新的同步状态，需要将绑定到当前线程的事务信息清除
										3.doCleanupAfterCompletion(status.getTransaction());如果是新事务，需要做一些清除资源的操作
											1.TransactionSynchronizationManager.unbindResource(obtainDataSource());将数据连接从当前线程中解除绑定
											2.Connection con = txObject.getConnectionHolder().getConnection();释放链接
											3.con.setAutoCommit(true);恢复数据库连接的自动提交属性
											4.DataSourceUtils.resetConnectionAfterTransaction(con, txObject.getPreviousIsolationLevel());重置数据库连接
											5.DataSourceUtils.releaseConnection(con, this.dataSource);如果当前事务是独立的新创建的事务则在事务完成时释放链接
											6.txObject.getConnectionHolder().clear();释放连接信息
										4.resume(transaction, (SuspendedResourcesHolder) status.getSuspendedResources());如果在事务执行前有事务挂起，那么将当前事务执行结束后需要挂起的事务恢复
					4.txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());不满足条件，即使抛出异常，也会提交事务

				9.事务提交
					如果执行过程没有出现异常，那么就可以走正常的事务提交流程了
					commitTransactionAfterReturning(txInfo);
						1.判断事务信息于事务状态是否存在
						2.txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());
							1.defStatus.isLocalRollbackOnly()
								之前在异常处理模块，当某个事务，既没有保存点又不是新事务，那么只是设置回滚标识，回滚标识这里就派上用场了。

								当某个事务时另外一个事务的嵌入事务，但是又不在spring的管理范围内，或者无法设置保存点。那么spring会通过设置回滚标识的方式来禁止提交。首先当某个嵌入事务发生回滚的时候会设置回滚标识，等到外部事务时，一旦判断出当前事务流设置了回滚标识，则由外部事务来统一进行整体事务的回滚。
								所以，当事务没有被异常捕获的时候也并不意味着事务会被提交；
							2.processRollback(defStatus, false); 回滚事务

							3.!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly() 设置只读，但是需要提交事务
							4.processRollback(defStatus, true); 回滚事务
							5.processCommit(defStatus); 提交事务
								1.prepareForCommit(status); 预留接口，子类实现
								2.triggerBeforeCommit(status); 添加的TransactionSynchronization中的对应方法的调用
								3.triggerBeforeCompletion(status); 添加的TransactionSynchronization中的对应方法的调用
								4.status.releaseHeldSavepoint();如果是保存点提交，则清除保存点信息
								5.doCommit(status);如果是独立事务，则直接提交
								6.triggerBeforeCompletion(status); 添加的TransactionSynchronization中的对应方法的调用
								7.doRollbackOnCommitException(status, ex); 提交过程存在异常则回滚
								8.triggerAfterCommit(status);添加的TransactionSynchronization中的对应方法的调用
								9.triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);添加的TransactionSynchronization中的对应方法的调用
								10.cleanupAfterCompletion(status);添加的TransactionSynchronization中的清除方法的调用

								上述方法主要做了以下事情
									1.当事务状态中存在保存点信息的话，便不会去提交事务
									2.当事务非新事务的时候也不会去执行提交事务操作
										此条件主要是考虑内嵌事务的情况，对于内嵌事务，在spring中正常的处理方式是将内嵌事务开始之前设置保存点，一旦内嵌事务出现异常便根据保存点信息进行回滚，但是没有出现异常，内嵌事务不会单独提交，而是根据事务流由最外层事务负责提交，所以如果当前存在保存点信息，便不是最外层事务，不做保存操作，对于是否新事务的判断也是基于此考虑。
											如果程序流经过了事务的重重把关，最后顺利进入提交流程，那么同样，spring会将事务提交操作引导至底层数据库链接的API，进行提交操作




		2020-12-21 17：49
			事务和AOP的阅读花了我巨量的时间，不过这一部分仍然不是很懂，对于这个的阅读很耗费时间和精力；这两个模块的代码；可以说是整个阅读过程中觉得最复杂部分了

	springmvc
		spring框架提供了构建web应用程序的全功能MVC模块，通过策略接口，Spring框架是高度可配置的，并且支持多种视图技术；springMvc分离了控制器，模型对象，分派器以及处理程序对象的角色；这种分离让它更加容易进行定制；

		Spring的mvc是基于Serlvet功能实现的；通过实现Servlet接口的DispactherServlet来封装其核心功能实现，通过将请求分派给处理程序；同时带有可配置的处理器映射，视图解析，本地语言，主题解析以及文件上传支持；默认的处理程序是非常简单的Controller接口，只有一个方法ModelAndView handlerRequest(request， response)；spring 提供一个控制器层次结构，可以派生子类。
			SpringMvc解决的问题可以归类为以下几点：
				1.将web页面的请求传给服务器
				2.根据不同请求处理不同的逻辑单元
				3.返回处理结果数据并跳转至响应的页面

		springMvc之所以要配置web.xml，其实最关键的是要配置两个地方
			1.contextConfigLocation
				spring的核心就是配置文件，可以说配置文件是spring中必不可少的东西，而这个参数就是使web与spring的配置文件相结合的一个关键配置
			2.DispatcherServlet
				包含了SpringMvc的请求逻辑，spring使用此类拦截web请求并进行相应的逻辑处理

		InternalResourceViewResolver JSP的视图解析器


		ContextLoaderListener
			ContextLoaderListener的作用就是启动web容器时，自动装配ApplicationContext的配置信息，因为它实现了ServletContextListener接口，在web.xml配置这个监听器，启动容器的时候就会默认执行其实现的方法，使用ServletContextListener接口，开发者能够在为客户端请求提供服务之前向ServletContext中添加任意对象，这个对象在ServletContext启动的时候被初始化，然后在ServletContext整个运行期间都是可见的


			WebApplicationContext 
				WebApplicationContext 继承自ApplicationContext，在ApplicationContext之上做了一些扩展。追加了一些特定于Web的操作及属性，

			initWebApplicationContext(ServletContext servletContext) 初始化WebApplicationContext
				1.createWebApplicationContext(servletContext); 如果context为空，则创建上下文
					1.determineContextClass(ServletContext servletContext) 获取className，如果有配置则使用配置的 在initParam里面contextClass
						如果没有配置，则获取
						org.springframework.web.context.support.XmlWebApplicationContext
						具体是从ContextLoader.properties获取默认信息，然后获取默认的WebApplicationContext
				2.loadParentContext(servletContext); 如果当前的context属于ConfigurableWebApplicationContext 寻找它的父容器，设置到当前容器里
				3.configureAndRefreshWebApplicationContext(cwac, servletContext); 配置环境与加载容器
					1.校验容器Id，如果初始化容器有配置id信息 initparam的contextId，就设置为当前容器的id， 如果没有则使用默认的容器id
					2.将servletContext设置到当前容器
					3.获取contextConfigLocation的信息，设置配置属性信息，这个配置是spring的核心配置
					4.wac.getEnvironment(); 获取环境信息，如果当前不存在，那么就创建一个上下文环境
						((ConfigurableWebEnvironment) env).initPropertySources(sc, null); 初始化环境
					5.customizeContext(sc, wac); 留给用户实现
					6.wac.refresh(); 刷新容器


		DispatcherServlet 
			在springMvc中，contextLoaderListener只是辅助功能，真正的逻辑实现还是在DispatcherServlet中进行的，DispatcherServlet是Servlet接口的实现类。
			servlet 是java编写的程序，此程序是基于Http协议的，在服务端运行的(如， tomcat)是按照Servlet规范运行的一个java类。主要是处理客户端请求并其响应结果返回给客户端，Servlet的生命周期是由Servlet的容器来控制的。它可以分成3个阶段： 初始化， 运行， 销毁
				1.初始化
					1.servlet容器加载servlet类，把servlet类的.class文件加载到内存中
					2.servlet容器创建一个ServletConfig对象。ServletConfig对象包含了Servlet的初始化配置信息
					3.servlet容器创建一个servlet对象
					4.servlet容器调用servlet对象的init方法
				2.运行
					当servlet容器接收到一个请求的时候，servlet容器会针对这个请求创建ServletRequest和SerlvetResponse对象，然后调用service方法，并将两个参数传递给service方法，service方法通过servletRequest对象获取请求信息，并且处理该请求，再通过ServletResponse对象生成这个请求的响应结果，最后销毁ServletRequest和ServletResponse对象，我们不管这个请求是POST还是GET，最后都会交给service方法处理
				3.销毁
					当web应用被终止的时候，servlet容器会先调用servlet对象的desctory方法，





				






			































