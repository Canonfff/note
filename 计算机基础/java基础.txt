### 为什么重写了equals方法必须重写hashCode方法?

首先看看equals方法与hashCode方法相关规定

> 1. 如果两个对象相等，则hashcode一定也是相同的
> 2. 两个对象相等,对两个对象分别调用equals方法都返回true
> 3. 两个对象有相同的hashcode值，它们也不一定是相等的
> 4. **因此，equals方法被覆盖过，则hashCode方法也必须被覆盖**
> 5. hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）



equals方法源码

```java
public boolean equals(Object obj) {
        return (this == obj);
    }
```

在没有重写equals方法的时候,使用equals方法其实就是等价于==;



hashCode源码

```java
public native int hashCode();
```

hashCode方法是获取hash值(哈希码,也就是散列码);

说白了就是返回一个int类型的数值;这个哈希码的作用是确定该对象在哈希表中的索引位置;

```text
我们都知道，散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！
散列表的本质是通过数组实现的。当我们要获取散列表中的某个“值”时，实际上是要获取数组中的某个位置的元素。而数组的位置，就是通过“键”来获取的；更进一步说，数组的位置，是通过“键”对应的散列码计算得到的。
```





两个对象相等，hashcode一定相等

> 

两个对象不等，hashcode不一定不等

> 

hashcode相等，两个对象不一定相等

> 因为hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。
>
> 我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本

hashcode不等，两个对象一定不等

> 





网友参考文章;

https://www.cnblogs.com/skywang12345/p/3324958.html



### 为什么java中只有值传递?

首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。**按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。** 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。

**Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。**

> 讲人话;就是说方法传递的内存中地址值