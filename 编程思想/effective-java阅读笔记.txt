2020-09-02
开始学习effective-java

创建和销毁对象
	建造者模式
		建造者模式优点:
			1.清晰的定义构建所需参数,
			2.可以一次性调用build方法完成构建
			3.保证构建的安全性和可读性
		建造者模式也适用与类层次结构
			建造者模式,适用于那种多种参数构造的类;

		建造者模式,在使用的时候的,会使系统的复杂性增加,一定程度上增加系统性能的开销


	单例模式抵御反射
		判断是否第二次创建,抛出异常


	基本类型要优于包装类型


	内存泄漏		
		1.过期的对象引用
			过期的对象,仍然保持引用,但是没有及时处理
		2.缓存
			存放的对象一直没有清理
		3.监听器以及回调
			注册回调之后,没有显示的取消回调,那么回调就会不断累积起来

	避免使用终结方法和清除方法
		1.终结方法finalizer 尽量避免使用,在java9中使用了cleaner替代了finalizer
			finalizer和cleaner方法不能保证及时执行,从一个对象变成不可达开始,到的它的finalizer方法被调用执行,所花费的时间是任意长的


	try-with-resources 优于 try-finally
		1.try-finally
			try{

			} finally{

			}

		2.try-with-resources
			try(InputStream in = new FileInputStream(src);OutputStream out = new FileOutputStream(dst)) {

			}
			这种会自动调用close方法


	静态类要优于非静态类
		嵌套类是定义在类的内部的类
		嵌套类的设计目的是为了为它的外部类服务
			1.静态内部类
			2.非静态内部类
			3.匿名内部类
			4.局部内部类


		非静态类的每个实例都隐式的和外围类的一个实例相关联,在非静态内部类的实例方法可以调用外围类的实例方法;在没有外围类的情况下,想要创建非静态内部类是不可能实现的
		当非静态内部类被创建的时候,它和外围类的关系也随着建立起来;这种构建需要消耗非静态内部类实例的空间,并且会增加构造的时间开销;
		非静态内部类需要依赖外围类,保存这份引用需要额外的时间和空间,并且会导致外围在符合垃圾回收的时候却仍然能够被保留,导致内存泄漏


	泛型


	注解
		注解优于命名模式
		命名模式有局限性
			1.耦合性太强,只能以规定名称开头,无法自动识别错误
			2.无法确保他们只应用于相应的程序元素上
			3.没有提供参数值与程序相关元素关联起来的好方法

	函数接口,lambda,方法引用
		1.lambda优于匿名类
			匿名类满足了传统的面向对象设计模式对函数对象的需求,最有名的策略模式


		java8新特性
			1.Map的merge方法是如果不存在这个键就直接存入,如果存在这个键,那么就使用方法引用比较
			2.Integer等包装类在java8中都引入了一个新的方法 sum

		Function
			1.一共有43个接口
			2.其中有6个基础接口
				1.UnaryOperator
				2.BinaryOperator
				3.predicate
				4.Function
				5.Supplier
				6.Consumer
	
2020-09-07 这本书并不太难懂,相反,我觉得理解是很好理解的;而且大多数都是经验教条;并没有什么十分晦涩的东西,但是要完全的理解却也是非常困难的;非常困难的;因为其中大部分设计的都是一些编程思想,思维逻辑等方面的东西;能做到这么的轻描淡写,相比要付出的努力并不少;从另一个方面来说,长期以来,我围绕java的东西大多数都是针对于spring去编程,或者说,很大的时候,我几乎就认为框架本身就是java,确实这是一种本末倒置;正是因为java语言足够优秀,才能衍生出这么多优秀的框架,只是针对语言本身而言;

	从java7开始,应该使用的随机数是ThreadLocalRandom,它会生成更高质量的随机数,并且速度非常快;

	异常转译
		目前在项目中存在很多异常转译的情况,但是这些异常其实我个人觉得非常没有必要,因为它对于代码的结构的破坏很大,异常链信息丢失;这种无疑是给寻找bug的过程添加了非常大的阻碍;其实在这里因为自定义的异常没有设置支持链,如果异常没有设置支持链,可以调用Throwable的initCause方法设置原因

	并发
		java语言规范中保证一个读或者写一个变量是原子的(atomic),除非这个变量是long或者是double;
			1.这个是因为long和double都是64位的,而32位系统能处理的最大长度是32;所以long和double的读写将分成两次32的读写操作

	骨架实现类可以把接口方法的调用转发到内部实现类上,这种方法被称为模拟多重继承


	序列化
		其它方法优于序列化

2020-09-08 16:08
完成书籍阅读,本书总体来说,是偏向于代码思想的编程指导;说了很多JDK中的设计原理,细节等;对于一些编码规范也进行了说明
涉及了性能,安全等;本书面向的群体应该是高级java工程师;而且,确实很吊,因为其完全是根据JDK本身出发对现有的一些问题进行论述;站在的层面不同;已经站在了编程语言的层面去看待问题,不只因为他是JDK源码的作者,而是作为一个IT工程,从客观的角度描述java这门语言





